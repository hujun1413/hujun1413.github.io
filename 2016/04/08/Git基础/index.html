<!doctype html>



  


<html class="theme-next mist use-motion">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>



<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />












  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css"/>




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  




<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.4.0" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.0.1" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="Git," />





  <link rel="alternate" href="/atom.xml" title="胡君的个人博客" type="application/atom+xml" />




  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.0.1" />






<meta name="description" content="参考廖雪峰的官方网站Git教程git clone，push，pull，fetch命令详解。（转载）读完本章你就能上手使用 Git 了。本章将介绍几个最基本的，也是最常用的 Git 命令，以后绝大多数时间里用到的也就是这几个命令。读完本章，你就能初始化一个新的代码仓库，做一些适当配置；开始或停止跟踪某些文件；暂存或提交某些更新。我们还会展示如何让 Git 忽略某些文件，或是名称符合特定模式的文件；如">
<meta property="og:type" content="article">
<meta property="og:title" content="Git基础">
<meta property="og:url" content="http://hujun1413.github.io/2016/04/08/Git基础/index.html">
<meta property="og:site_name" content="胡君的个人博客">
<meta property="og:description" content="参考廖雪峰的官方网站Git教程git clone，push，pull，fetch命令详解。（转载）读完本章你就能上手使用 Git 了。本章将介绍几个最基本的，也是最常用的 Git 命令，以后绝大多数时间里用到的也就是这几个命令。读完本章，你就能初始化一个新的代码仓库，做一些适当配置；开始或停止跟踪某些文件；暂存或提交某些更新。我们还会展示如何让 Git 忽略某些文件，或是名称符合特定模式的文件；如">
<meta property="og:updated_time" content="2016-12-19T08:01:56.851Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Git基础">
<meta name="twitter:description" content="参考廖雪峰的官方网站Git教程git clone，push，pull，fetch命令详解。（转载）读完本章你就能上手使用 Git 了。本章将介绍几个最基本的，也是最常用的 Git 命令，以后绝大多数时间里用到的也就是这几个命令。读完本章，你就能初始化一个新的代码仓库，做一些适当配置；开始或停止跟踪某些文件；暂存或提交某些更新。我们还会展示如何让 Git 忽略某些文件，或是名称符合特定模式的文件；如">



<script type="text/javascript" id="hexo.configuration">
  var NexT = window.NexT || {};
  var CONFIG = {
    scheme: 'Mist',
    sidebar: {"position":"right","display":"always"},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: 0,
      author: '博主'
    }
  };
</script>

  <title> Git基础 | 胡君的个人博客 </title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  










  
  
    
  

  <div class="container one-collumn sidebar-position-right page-post-detail ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-meta ">
  

  <div class="custom-logo-site-title">
    <a href="/"  class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <span class="site-title">胡君的个人博客</span>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>
  <p class="site-subtitle">你必须非常努力才能看起来毫不费力</p>
</div>

<div class="site-nav-toggle">
  <button>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
  </button>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-home fa-fw"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories" rel="section">
            
              <i class="menu-item-icon fa fa-th fa-fw"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-archive fa-fw"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-tags fa-fw"></i> <br />
            
            标签
          </a>
        </li>
      

      
    </ul>
  

  
</nav>

 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                Git基础
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-04-08T16:26:26+08:00" content="2016-04-08">
              2016-04-08
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/Linux/" itemprop="url" rel="index">
                    <span itemprop="name">Linux</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2016/04/08/Git基础/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2016/04/08/Git基础/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        <p>参考<a href="http://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000" target="_blank" rel="external">廖雪峰的官方网站Git教程</a><br><a href="http://blog.csdn.net/u012575819/article/details/50553501" target="_blank" rel="external">git clone，push，pull，fetch命令详解。（转载）</a><br>读完本章你就能上手使用 Git 了。本章将介绍几个最基本的，也是最常用的 Git 命令，以后绝大多数时间里用到的也就是这几个命令。读完本章，你就能初始化一个新的代码仓库，做一些适当配置；开始或停止跟踪某些文件；暂存或提交某些更新。我们还会展示如何让 Git 忽略某些文件，或是名称符合特定模式的文件；如何既快且容易地撤消犯下的小错误；如何浏览项目的更新历史，查看某两次更新之间的差异；以及如何从远程仓库拉数据下来或者推数据上去。<br><a id="more"></a></p>
<h2 id="本地管理"><a href="#本地管理" class="headerlink" title="本地管理"></a>本地管理</h2><h3 id="创建版本库"><a href="#创建版本库" class="headerlink" title="创建版本库"></a>创建版本库</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">mkdir blog</span><br><span class="line"><span class="built_in">cd</span> blog</span><br><span class="line">git init</span><br><span class="line"></span><br><span class="line">git add readme.txt</span><br><span class="line">git add .   <span class="comment">#添加所有文件</span></span><br><span class="line">git add --all  <span class="comment">#当有文件被删除时，用此命令确认删除</span></span><br><span class="line">               <span class="comment">#用于将这些工作区内已删除的文件从版本库中删除</span></span><br><span class="line"></span><br><span class="line">git commit -m <span class="string">"write a readme file"</span></span><br><span class="line">git commit <span class="_">-a</span> -m <span class="string">""</span>  <span class="comment">#不提交新创建的，但把修改的和删除的都提交</span></span><br><span class="line">git commit --help  <span class="comment">#查看帮助</span></span><br></pre></td></tr></table></figure>
<h3 id="版本回退"><a href="#版本回退" class="headerlink" title="版本回退"></a>版本回退</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">log</span>    <span class="comment">#查看提交历史</span></span><br><span class="line">或者：git <span class="built_in">log</span> --pretty=oneline</span><br><span class="line">git <span class="built_in">log</span> --graph  <span class="comment">#查看分支合并图</span></span><br><span class="line"></span><br><span class="line">git reset --hard [version number,eg:ea345]</span><br><span class="line"></span><br><span class="line">git reflog  @查看命令历史</span><br></pre></td></tr></table></figure>
<h3 id="管理修改"><a href="#管理修改" class="headerlink" title="管理修改"></a>管理修改</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">git status   <span class="comment">#查看状态</span></span><br><span class="line">未add:</span><br><span class="line">git checkout -- [file name,eg:readme.txt]  <span class="comment">#丢弃工作区的修改</span></span><br><span class="line">已add未commit:</span><br><span class="line">git reset HEAD [file name,eg:readme.txt]  <span class="comment">#撤销暂存区的修改</span></span><br><span class="line">git checkout -- [file name,eg:readme.txt]  <span class="comment">#丢弃工作区的修改</span></span><br><span class="line">已commit:</span><br><span class="line">版本回退：</span><br><span class="line">git reset --hard HEAD/[version number,eg:ea345]</span><br></pre></td></tr></table></figure>
<h3 id="删除文件"><a href="#删除文件" class="headerlink" title="删除文件"></a>删除文件</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git rm test.txt  <span class="comment">#从暂存区库中删除文件</span></span><br><span class="line"></span><br><span class="line">git checkout -- test.txt  <span class="comment">#从版本库恢复工作区内已删除的文件</span></span><br></pre></td></tr></table></figure>
<h2 id="远程仓库"><a href="#远程仓库" class="headerlink" title="远程仓库"></a>远程仓库</h2><h3 id="添加远程库"><a href="#添加远程库" class="headerlink" title="添加远程库"></a>添加远程库</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#用户主目录没有.ssh目录</span></span><br><span class="line">ssh-keygen -t rsa -C <span class="string">"hujun1413.bupt.edu.cn"</span></span><br><span class="line"><span class="comment">#在github的ADD SSH KEY中粘贴.ssh/id_rsa.pub的内容</span></span><br><span class="line">git remote add origin git@github.com:hujun1413/hujun1413.github.io.git</span><br><span class="line"></span><br><span class="line">git push -u origin hexo</span><br><span class="line">git push origin hexo</span><br></pre></td></tr></table></figure>
<h3 id="从远程库克隆"><a href="#从远程库克隆" class="headerlink" title="从远程库克隆"></a>从远程库克隆</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> git://github.com:xx/xxx.git  <span class="comment">#不支持push</span></span><br><span class="line">git <span class="built_in">clone</span> git@github.com:hujun1413/hujun1413.github.io.git </span><br><span class="line">git <span class="built_in">clone</span> -b hexo https://github.com/hujun1413/hujun1413.github.io.git --depth 1 blog</span><br><span class="line"><span class="comment">#只克隆仓库中的hexo分支,克隆深度为1，存在当前目录的blog文件夹下</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#解决方案：将远程主机的url修改成SSH/HTTP协议(每次都要输密码)</span></span><br><span class="line">git remote <span class="built_in">set</span>-url origin git@github.com:hujun1413/hujun1413.github.io.git</span><br><span class="line">git remote <span class="built_in">set</span>-url origin https://github.com/hujun1413/hujun1413.github.io.git</span><br></pre></td></tr></table></figure>
<h3 id="创建-合并-删除分支"><a href="#创建-合并-删除分支" class="headerlink" title="创建/合并/删除分支"></a>创建/合并/删除分支</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">git branch hexo    <span class="comment">#创建分支</span></span><br><span class="line">git checkout hexo    <span class="comment">#切换分支</span></span><br><span class="line">git checkout -b hexo = git branch hexo + git checkout hexo   <span class="comment">#创建并切换至hexo分支,默认从当前分支copy</span></span><br><span class="line">git checkout -b master origin/master <span class="comment">#从远程的origin/master创建分支</span></span><br><span class="line"></span><br><span class="line">git branch      <span class="comment">#查看本地分支</span></span><br><span class="line">git branch <span class="_">-a</span>   <span class="comment">#查看所有分支</span></span><br><span class="line">git branch -r   <span class="comment">#查看远程分支</span></span><br><span class="line">git branch <span class="_">-d</span>/-D hexo  <span class="comment">#删除hexo分支，-D强制删除</span></span><br><span class="line">git branch -r <span class="_">-d</span> origin/hongchangfirst <span class="comment">#删除在本地的远程分支</span></span><br><span class="line"></span><br><span class="line">git merge hexo  <span class="comment">#将当前分支与hexo 分支进行合并</span></span><br><span class="line">git merge --no-ff -m <span class="string">"merge with no-ff"</span> dev   <span class="comment">#--no-ff参数，表示禁用Fast forward：</span></span><br><span class="line"></span><br><span class="line">git rebase origin/master   <span class="comment">#合并，但把另一个分支的最新commit改变为当前分支的基础。</span></span><br><span class="line">                           <span class="comment">#让分支历史看起来像没有经过任何合并</span></span><br></pre></td></tr></table></figure>
<h3 id="解决冲突"><a href="#解决冲突" class="headerlink" title="解决冲突"></a>解决冲突</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git merge hexo</span><br><span class="line">git add [file_name]</span><br><span class="line">git commit -m <span class="string">"confict fixed"</span></span><br></pre></td></tr></table></figure>
<h3 id="对比差异"><a href="#对比差异" class="headerlink" title="对比差异"></a>对比差异</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">git diff  工作区与暂存区的差异</span><br><span class="line">git diff --cached / git diff --staged  暂存区(staged)和版本库的差异</span><br><span class="line">git diff HEAD  / git diff [当前branch]  工作区和版本库的差异</span><br><span class="line">git diff sha1 sha2</span><br><span class="line">git diff tmp  当前分支与tmp分支的差异</span><br></pre></td></tr></table></figure>
<h3 id="fetch"><a href="#fetch" class="headerlink" title="fetch"></a>fetch</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">git fetch &lt;远程主机名&gt; &lt;分支名&gt;  <span class="comment">#取回origin主机的master分支。</span></span><br><span class="line"><span class="comment">#所取回的更新，在本地主机上要用"远程主机名/分支名"的形式读取。比如origin主机的master，就要用origin/master读取。</span></span><br><span class="line"></span><br><span class="line">git fetch origin hexo</span><br><span class="line">git checkout -b tmp origin/hexo  <span class="comment">#在origin/master的基础上，创建一个新分支</span></span><br><span class="line">git checkout hexo</span><br><span class="line">git merge tmp</span><br></pre></td></tr></table></figure>
<h3 id="pull"><a href="#pull" class="headerlink" title="pull"></a>pull</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">git pull &lt;远程主机名&gt; &lt;远程分支名&gt;:&lt;本地分支名&gt;</span><br><span class="line"></span><br><span class="line">合并需要采用rebase模式，可以使用--rebase选项。</span><br><span class="line">git pull --rebase &lt;远程主机名&gt; &lt;远程分支名&gt;:&lt;本地分支名&gt;</span><br></pre></td></tr></table></figure>
<h3 id="push"><a href="#push" class="headerlink" title="push"></a>push</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">git push &lt;远程主机名&gt; &lt;本地分支名&gt;:&lt;远程分支名&gt;</span><br><span class="line">git push origin master</span><br><span class="line">把本地master分支的最新修改推送至GitHub</span><br><span class="line"></span><br><span class="line">git push不会推送标签（tag），除非使用--tags选项。</span><br><span class="line">git push origin --tags</span><br><span class="line"></span><br><span class="line">如果远程主机的版本比本地版本更新，推送时Git会报错，要求先在本地做git pull合并差异，然后再推送到远程主机。这时，如果你一定要推送，可以使用--force选项。</span><br><span class="line">git push --force origin   <span class="comment">#远程主机上更新的版本被覆盖</span></span><br><span class="line"></span><br><span class="line">git push origin :article    <span class="comment">#删除远程的article分支</span></span><br><span class="line">git push origin article     <span class="comment">#当前分支推送至远程，若远程不存在则创建之</span></span><br></pre></td></tr></table></figure>
<h3 id="remote"><a href="#remote" class="headerlink" title="remote"></a>remote</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">git remote -v 查看远程主机的网址</span><br><span class="line">git <span class="built_in">clone</span> -o jQuery https://github.com/jquery/jquery.git</span><br><span class="line"><span class="comment">#克隆的时候，指定远程主机叫做jQuery。</span></span><br><span class="line"></span><br><span class="line">git remote show &lt;主机名&gt;  <span class="comment">#查看该主机的详细信息。</span></span><br><span class="line"></span><br><span class="line">git remote add &lt;主机名&gt; &lt;网址&gt;  <span class="comment">#添加远程主机。</span></span><br><span class="line"></span><br><span class="line">git remote rm &lt;主机名&gt;  <span class="comment">#删除远程主机。</span></span><br><span class="line"></span><br><span class="line">git remote rename &lt;原主机名&gt; &lt;新主机名&gt;  <span class="comment">#用于远程主机的改名。</span></span><br><span class="line"></span><br><span class="line">git remote <span class="built_in">set</span>-url origin git@github.com:hujun1413/hujun1413.github.io.git</span><br><span class="line"><span class="comment">#更改主机的url</span></span><br></pre></td></tr></table></figure>
<h3 id="删除远程的提交记录"><a href="#删除远程的提交记录" class="headerlink" title="删除远程的提交记录"></a>删除远程的提交记录</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">git reset --hard [version number,eg:ea345]  <span class="comment">#回退到某个版本</span></span><br><span class="line">git push --force    <span class="comment">#强行推送至远程，远程的提交记录则只到该次提交，之后的提交均被删除</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#或直接删除远程分支后重新提交建立新的分支</span></span><br><span class="line">git push origin :article</span><br><span class="line">git push origin article</span><br></pre></td></tr></table></figure>
<h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">git clean -df    <span class="comment">#清理git的本地缓存</span></span><br><span class="line">git rm --cached bundle/xxxx  删除子模组</span><br><span class="line">git gc  <span class="comment">#压缩历史信息来节约磁盘和内容空间</span></span><br><span class="line">git branch --set-upstream master origin/next  <span class="comment">#指定master分支追踪origin/next分支</span></span><br></pre></td></tr></table></figure>
<p>取得项目的 Git 仓库<br>有两种取得 Git 项目仓库的方法。第一种是在现存的目录下，通过导入所有文件来创建新的 Git 仓库。第二种是从已有的 Git 仓库克隆出一个新的镜像仓库来。</p>
<p>在工作目录中初始化新仓库<br>要对现有的某个项目开始用 Git 管理，只需到此项目所在的目录，执行：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git init</span><br></pre></td></tr></table></figure></p>
<p>初始化后，在当前目录下会出现一个名为 .git 的目录，所有 Git 需要的数据和资源都存放在这个目录中。不过目前，仅仅是按照既有的结构框架初始化好了里边所有的文件和目录，但我们还没有开始跟踪管理项目中的任何一个文件。（在第九章我们会详细说明刚才创建的 .git 目录中究竟有哪些文件，以及都起些什么作用。）</p>
<p>如果当前目录下有几个文件想要纳入版本控制，需要先用 git add 命令告诉 Git 开始对这些文件进行跟踪，然后提交：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git add *.c</span><br><span class="line">$ git add README</span><br><span class="line">$ git commit -m <span class="string">'initial project version'</span></span><br></pre></td></tr></table></figure></p>
<p>稍后我们再逐一解释每条命令的意思。不过现在，你已经得到了一个实际维护着若干文件的 Git 仓库。</p>
<p>从现有仓库克隆<br>如果想对某个开源项目出一份力，可以先把该项目的 Git 仓库复制一份出来，这就需要用到 git clone 命令。如果你熟悉其他的 VCS 比如 Subversion，你可能已经注意到这里使用的是 clone 而不是 checkout。这是个非常重要的差别，Git 收取的是项目历史的所有数据（每一个文件的每一个版本），服务器上有的数据克隆之后本地也都有了。实际上，即便服务器的磁盘发生故障，用任何一个克隆出来的客户端都可以重建服务器上的仓库，回到当初克隆时的状态（虽然可能会丢失某些服务器端的挂钩设置，但所有版本的数据仍旧还在，有关细节请参考第四章）。</p>
<p>克隆仓库的命令格式为 git clone [url]。比如，要克隆 Ruby 语言的 Git 代码仓库 Grit，可以用下面的命令：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git clone git://github.com/schacon/grit.git</span><br></pre></td></tr></table></figure></p>
<p>这会在当前目录下创建一个名为grit的目录，其中包含一个 .git 的目录，用于保存下载下来的所有版本记录，然后从中取出最新版本的文件拷贝。如果进入这个新建的 grit 目录，你会看到项目中的所有文件已经在里边了，准备好后续的开发和使用。如果希望在克隆的时候，自己定义要新建的项目目录名称，可以在上面的命令末尾指定新的名字：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git <span class="built_in">clone</span> git://github.com/schacon/grit.git mygrit</span><br></pre></td></tr></table></figure></p>
<p>唯一的差别就是，现在新建的目录成了 mygrit，其他的都和上边的一样。</p>
<p>Git 支持许多数据传输协议。之前的例子使用的是 git:// 协议，不过你也可以用 http(s):// 或者 user@server:/path.git 表示的 SSH 传输协议。我们会在第四章详细介绍所有这些协议在服务器端该如何配置使用，以及各种方式之间的利弊。</p>
<p>记录每次更新到仓库<br>现在我们手上已经有了一个真实项目的 Git 仓库，并从这个仓库中取出了所有文件的工作拷贝。接下来，对这些文件作些修改，在完成了一个阶段的目标之后，提交本次更新到仓库。</p>
<p>请记住，工作目录下面的所有文件都不外乎这两种状态：已跟踪或未跟踪。已跟踪的文件是指本来就被纳入版本控制管理的文件，在上次快照中有它们的记录，工作一段时间后，它们的状态可能是未更新，已修改或者已放入暂存区。而所有其他文件都属于未跟踪文件。它们既没有上次更新时的快照，也不在当前的暂存区域。初次克隆某个仓库时，工作目录中的所有文件都属于已跟踪文件，且状态为未修改。</p>
<p>在编辑过某些文件之后，Git 将这些文件标为已修改。我们逐步把这些修改过的文件放到暂存区域，直到最后一次性提交所有这些暂存起来的文件，如此重复。所以使用 Git 时的文件状态变化周期如图 2-1 所示。</p>
<p>Insert 18333fig0201.png 图 2-1. 文件的状态变化周期</p>
<p>检查当前文件状态<br>要确定哪些文件当前处于什么状态，可以用 git status 命令。如果在克隆仓库之后立即执行此命令，会看到类似这样的输出：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git status</span><br><span class="line"><span class="comment"># On branch master</span></span><br><span class="line">nothing to commit (working directory clean)</span><br></pre></td></tr></table></figure></p>
<p>这说明你现在的工作目录相当干净。换句话说，所有已跟踪文件在上次提交后都未被更改过。此外，上面的信息还表明，当前目录下没有出现任何处于未跟踪的新文件，否则 Git 会在这里列出来。最后，该命令还显示了当前所在的分支是 master，这是默认的分支名称，实际是可以修改的，现在先不用考虑。下一章我们就会详细讨论分支和引用。</p>
<p>现在让我们用 vim 创建一个新文件 README，保存退出后运行 git status 会看到该文件出现在未跟踪文件列表中：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ vim README</span><br><span class="line">$ git status</span><br><span class="line"><span class="comment"># On branch master</span></span><br><span class="line"><span class="comment"># Untracked files:</span></span><br><span class="line"><span class="comment">#   (use "git add &lt;file&gt;..." to include in what will be committed)</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">#   README</span></span><br><span class="line">nothing added to commit but untracked files present (use <span class="string">"git add"</span> to track)</span><br></pre></td></tr></table></figure></p>
<p>在状态报告中可以看到新建的README文件出现在“Untracked files”下面。未跟踪的文件意味着Git在之前的快照（提交）中没有这些文件；Git 不会自动将之纳入跟踪范围，除非你明明白白地告诉它“我需要跟踪该文件”，因而不用担心把临时文件什么的也归入版本管理。不过现在的例子中，我们确实想要跟踪管理 README 这个文件。</p>
<p>跟踪新文件<br>使用命令 git add 开始跟踪一个新文件。所以，要跟踪 README 文件，运行：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git add README</span><br></pre></td></tr></table></figure></p>
<p>此时再运行 git status 命令，会看到 README 文件已被跟踪，并处于暂存状态：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ git status</span><br><span class="line"><span class="comment"># On branch master</span></span><br><span class="line"><span class="comment"># Changes to be committed:</span></span><br><span class="line"><span class="comment">#   (use "git reset HEAD &lt;file&gt;..." to unstage)</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">#   new file:   README</span></span><br><span class="line"><span class="comment">#</span></span><br></pre></td></tr></table></figure></p>
<p>只要在 “Changes to be committed” 这行下面的，就说明是已暂存状态。如果此时提交，那么该文件此时此刻的版本将被留存在历史记录中。你可能会想起之前我们使用 git init 后就运行了 git add 命令，开始跟踪当前目录下的文件。在 git add 后面可以指明要跟踪的文件或目录路径。如果是目录的话，就说明要递归跟踪该目录下的所有文件。（译注：其实 git add 的潜台词就是把目标文件快照放入暂存区域，也就是 add file into staged area，同时未曾跟踪过的文件标记为需要跟踪。这样就好理解后续 add 操作的实际意义了。）</p>
<p>暂存已修改文件<br>现在我们修改下之前已跟踪过的文件 benchmarks.rb，然后再次运行 status 命令，会看到这样的状态报告：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">$ git status</span><br><span class="line"><span class="comment"># On branch master</span></span><br><span class="line"><span class="comment"># Changes to be committed:</span></span><br><span class="line"><span class="comment">#   (use "git reset HEAD &lt;file&gt;..." to unstage)</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">#   new file:   README</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># Changes not staged for commit:</span></span><br><span class="line"><span class="comment">#   (use "git add &lt;file&gt;..." to update what will be committed)</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">#   modified:   benchmarks.rb</span></span><br><span class="line"><span class="comment">#</span></span><br></pre></td></tr></table></figure></p>
<p>文件 benchmarks.rb 出现在 “Changes not staged for commit” 这行下面，说明已跟踪文件的内容发生了变化，但还没有放到暂存区。要暂存这次更新，需要运行 git add 命令（这是个多功能命令，根据目标文件的状态不同，此命令的效果也不同：可以用它开始跟踪新文件，或者把已跟踪的文件放到暂存区，还能用于合并时把有冲突的文件标记为已解决状态等）。现在让我们运行git add 将 benchmarks.rb 放到暂存区，然后再看看 git status 的输出：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ git add benchmarks.rb</span><br><span class="line">$ git status</span><br><span class="line"><span class="comment"># On branch master</span></span><br><span class="line"><span class="comment"># Changes to be committed:</span></span><br><span class="line"><span class="comment">#   (use "git reset HEAD &lt;file&gt;..." to unstage)</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">#   new file:   README</span></span><br><span class="line"><span class="comment">#   modified:   benchmarks.rb</span></span><br><span class="line"><span class="comment">#</span></span><br></pre></td></tr></table></figure></p>
<p>现在两个文件都已暂存，下次提交时就会一并记录到仓库。假设此时，你想要在 benchmarks.rb 里再加条注释，重新编辑存盘后，准备好提交。不过且慢，再运行 git status 看看：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">$ vim benchmarks.rb </span><br><span class="line">$ git status</span><br><span class="line"><span class="comment"># On branch master</span></span><br><span class="line"><span class="comment"># Changes to be committed:</span></span><br><span class="line"><span class="comment">#   (use "git reset HEAD &lt;file&gt;..." to unstage)</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">#   new file:   README</span></span><br><span class="line"><span class="comment">#   modified:   benchmarks.rb</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># Changes not staged for commit:</span></span><br><span class="line"><span class="comment">#   (use "git add &lt;file&gt;..." to update what will be committed)</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">#   modified:   benchmarks.rb</span></span><br><span class="line"><span class="comment">#</span></span><br></pre></td></tr></table></figure></p>
<p>怎么回事？ benchmarks.rb 文件出现了两次！一次算未暂存，一次算已暂存，这怎么可能呢？好吧，实际上 Git 只不过暂存了你运行 git add 命令时的版本，如果现在提交，那么提交的是添加注释前的版本，而非当前工作目录中的版本。所以，运行了git add 之后又作了修订的文件，需要重新运行 git add 把最新版本重新暂存起来：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ git add benchmarks.rb</span><br><span class="line">$ git status</span><br><span class="line"><span class="comment"># On branch master</span></span><br><span class="line"><span class="comment"># Changes to be committed:</span></span><br><span class="line"><span class="comment">#   (use "git reset HEAD &lt;file&gt;..." to unstage)</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">#   new file:   README</span></span><br><span class="line"><span class="comment">#   modified:   benchmarks.rb</span></span><br><span class="line"><span class="comment">#</span></span><br></pre></td></tr></table></figure></p>
<p>忽略某些文件<br>一般我们总会有些文件无需纳入 Git 的管理，也不希望它们总出现在未跟踪文件列表。通常都是些自动生成的文件，比如日志文件，或者编译过程中创建的临时文件等。我们可以创建一个名为 .gitignore 的文件，列出要忽略的文件模式。来看一个实际的例子：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ cat .gitignore</span><br><span class="line">*.[oa]</span><br><span class="line">*~</span><br></pre></td></tr></table></figure></p>
<p>第一行告诉 Git 忽略所有以 .o 或 .a 结尾的文件。一般这类对象文件和存档文件都是编译过程中出现的，我们用不着跟踪它们的版本。第二行告诉 Git 忽略所有以波浪符（~）结尾的文件，许多文本编辑软件（比如 Emacs）都用这样的文件名保存副本。此外，你可能还需要忽略 log，tmp 或者 pid 目录，以及自动生成的文档等等。要养成一开始就设置好 .gitignore 文件的习惯，以免将来误提交这类无用的文件。</p>
<p>文件 .gitignore 的格式规范如下：</p>
<p>所有空行或者以注释符号 ＃ 开头的行都会被 Git 忽略。<br>可以使用标准的 glob 模式匹配。<br>匹配模式最后跟反斜杠（/）说明要忽略的是目录。<br>要忽略指定模式以外的文件或目录，可以在模式前加上惊叹号（!）取反。<br>所谓的 glob 模式是指 shell 所使用的简化了的正则表达式。星号（*）匹配零个或多个任意字符；[abc] 匹配任何一个列在方括号中的字符（这个例子要么匹配一个 a，要么匹配一个 b，要么匹配一个 c）；问号（?）只匹配一个任意字符；如果在方括号中使用短划线分隔两个字符，表示所有在这两个字符范围内的都可以匹配（比如 [0-9] 表示匹配所有 0 到 9 的数字）。</p>
<p>我们再看一个 .gitignore 文件的例子：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 此为注释 – 将被 Git 忽略</span></span><br><span class="line"><span class="comment"># 忽略所有 .a 结尾的文件</span></span><br><span class="line">*.a</span><br><span class="line"><span class="comment"># 但 lib.a 除外</span></span><br><span class="line">!lib.a</span><br><span class="line"><span class="comment"># 仅仅忽略项目根目录下的 TODO 文件，不包括 subdir/TODO</span></span><br><span class="line">/TODO</span><br><span class="line"><span class="comment"># 忽略 build/ 目录下的所有文件</span></span><br><span class="line">build/</span><br><span class="line"><span class="comment"># 会忽略 doc/notes.txt 但不包括 doc/server/arch.txt</span></span><br><span class="line">doc/*.txt</span><br></pre></td></tr></table></figure></p>
<p>查看已暂存和未暂存的更新<br>实际上 git status 的显示比较简单，仅仅是列出了修改过的文件，如果要查看具体修改了什么地方，可以用 git diff 命令。稍后我们会详细介绍 git diff，不过现在，它已经能回答我们的两个问题了：当前做的哪些更新还没有暂存？有哪些更新已经暂存起来准备好了下次提交？ git diff 会使用文件补丁的格式显示具体添加和删除的行。</p>
<p>假如再次修改 README 文件后暂存，然后编辑 benchmarks.rb 文件后先别暂存，运行 status 命令将会看到：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">$ git status</span><br><span class="line"><span class="comment"># On branch master</span></span><br><span class="line"><span class="comment"># Changes to be committed:</span></span><br><span class="line"><span class="comment">#   (use "git reset HEAD &lt;file&gt;..." to unstage)</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">#   new file:   README</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># Changes not staged for commit:</span></span><br><span class="line"><span class="comment">#   (use "git add &lt;file&gt;..." to update what will be committed)</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">#   modified:   benchmarks.rb</span></span><br><span class="line"><span class="comment">#</span></span><br></pre></td></tr></table></figure></p>
<p>要查看尚未暂存的文件更新了哪些部分，不加参数直接输入 git diff：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">$ git diff</span><br><span class="line">diff --git a/benchmarks.rb b/benchmarks.rb</span><br><span class="line">index 3cb747f..da65585 100644</span><br><span class="line">--- a/benchmarks.rb</span><br><span class="line">+++ b/benchmarks.rb</span><br><span class="line">@@ -36,6 +36,10 @@ def main</span><br><span class="line">           @commit.parents[0].parents[0].parents[0]</span><br><span class="line">         end</span><br><span class="line"></span><br><span class="line">+        run_code(x, <span class="string">'commits 1'</span>) <span class="keyword">do</span></span><br><span class="line">+          git.commits.size</span><br><span class="line">+        end</span><br><span class="line">+</span><br><span class="line">         run_code(x, <span class="string">'commits 2'</span>) <span class="keyword">do</span></span><br><span class="line">           <span class="built_in">log</span> = git.commits(<span class="string">'master'</span>, 15)</span><br><span class="line">           log.size</span><br></pre></td></tr></table></figure></p>
<p>此命令比较的是工作目录中当前文件和暂存区域快照之间的差异，也就是修改之后还没有暂存起来的变化内容。</p>
<p>若要看已经暂存起来的文件和上次提交时的快照之间的差异，可以用 git diff –cached 命令。（Git 1.6.1 及更高版本还允许使用 git diff –staged，效果是相同的，但更好记些。）来看看实际的效果：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">$ git diff --cached</span><br><span class="line">diff --git a/README b/README</span><br><span class="line">new file mode 100644</span><br><span class="line">index 0000000..03902a1</span><br><span class="line">--- /dev/null</span><br><span class="line">+++ b/README2</span><br><span class="line">@@ -0,0 +1,5 @@</span><br><span class="line">+grit</span><br><span class="line">+ by Tom Preston-Werner, Chris Wanstrath</span><br><span class="line">+ http://github.com/mojombo/grit</span><br><span class="line">+</span><br><span class="line">+Grit is a Ruby library fo extracting information from a Git repository</span><br></pre></td></tr></table></figure></p>
<p>请注意，单单 git diff 不过是显示还没有暂存起来的改动，而不是这次工作和上次提交之间的差异。所以有时候你一下子暂存了所有更新过的文件后，运行 git diff 后却什么也没有，就是这个原因。</p>
<p>像之前说的，暂存 benchmarks.rb 后再编辑，运行 git status 会看到暂存前后的两个版本：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">$ git add benchmarks.rb</span><br><span class="line">$ <span class="built_in">echo</span> <span class="string">'# test line'</span> &gt;&gt; benchmarks.rb</span><br><span class="line">$ git status</span><br><span class="line"><span class="comment"># On branch master</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># Changes to be committed:</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">#   modified:   benchmarks.rb</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># Changes not staged for commit:</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">#   modified:   benchmarks.rb</span></span><br><span class="line"><span class="comment">#</span></span><br></pre></td></tr></table></figure></p>
<p>现在运行 git diff 看暂存前后的变化：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$ git diff</span><br><span class="line">diff --git a/benchmarks.rb b/benchmarks.rb</span><br><span class="line">index e445e28..86b2f7c 100644</span><br><span class="line">--- a/benchmarks.rb</span><br><span class="line">+++ b/benchmarks.rb</span><br><span class="line">@@ -127,3 +127,4 @@ end</span><br><span class="line"> main()</span><br><span class="line"></span><br><span class="line"> <span class="comment">##pp Grit::GitRuby.cache_client.stats</span></span><br><span class="line">+<span class="comment"># test line</span></span><br></pre></td></tr></table></figure></p>
<p>然后用 git diff –cached 查看已经暂存起来的变化：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">$ git diff --cached</span><br><span class="line">diff --git a/benchmarks.rb b/benchmarks.rb</span><br><span class="line">index 3cb747f..e445e28 100644</span><br><span class="line">--- a/benchmarks.rb</span><br><span class="line">+++ b/benchmarks.rb</span><br><span class="line">@@ -36,6 +36,10 @@ def main</span><br><span class="line">          @commit.parents[0].parents[0].parents[0]</span><br><span class="line">        end</span><br><span class="line"></span><br><span class="line">+        run_code(x, <span class="string">'commits 1'</span>) <span class="keyword">do</span></span><br><span class="line">+          git.commits.size</span><br><span class="line">+        end</span><br><span class="line">+</span><br><span class="line">        run_code(x, <span class="string">'commits 2'</span>) <span class="keyword">do</span></span><br><span class="line">          <span class="built_in">log</span> = git.commits(<span class="string">'master'</span>, 15)</span><br><span class="line">          log.size</span><br></pre></td></tr></table></figure></p>
<p>提交更新<br>现在的暂存区域已经准备妥当可以提交了。在此之前，请一定要确认还有什么修改过的或新建的文件还没有 git add 过，否则提交的时候不会记录这些还没暂存起来的变化。所以，每次准备提交前，先用 git status 看下，是不是都已暂存起来了，然后再运行提交命令 git commit：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git commit</span><br></pre></td></tr></table></figure></p>
<p>这种方式会启动文本编辑器以便输入本次提交的说明。（默认会启用 shell 的环境变量 $EDITOR 所指定的软件，一般都是 vim 或 emacs。当然也可以按照第一章介绍的方式，使用 git config –global core.editor 命令设定你喜欢的编辑软件。）</p>
<p>编辑器会显示类似下面的文本信息（本例选用 Vim 的屏显方式展示）：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Please enter the commit message for your changes. Lines starting</span></span><br><span class="line"><span class="comment"># with '#' will be ignored, and an empty message aborts the commit.</span></span><br><span class="line"><span class="comment"># On branch master</span></span><br><span class="line"><span class="comment"># Changes to be committed:</span></span><br><span class="line"><span class="comment">#   (use "git reset HEAD &lt;file&gt;..." to unstage)</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">#       new file:   README</span></span><br><span class="line"><span class="comment">#       modified:   benchmarks.rb</span></span><br><span class="line">~</span><br><span class="line">~</span><br><span class="line">~</span><br><span class="line"><span class="string">".git/COMMIT_EDITMSG"</span> 10L, 283C</span><br></pre></td></tr></table></figure></p>
<p>可以看到，默认的提交消息包含最后一次运行 git status 的输出，放在注释行里，另外开头还有一空行，供你输入提交说明。你完全可以去掉这些注释行，不过留着也没关系，多少能帮你回想起这次更新的内容有哪些。（如果觉得这还不够，可以用 -v选项将修改差异的每一行都包含到注释中来。）退出编辑器时，Git 会丢掉注释行，将说明内容和本次更新提交到仓库。</p>
<p>另外也可以用 -m 参数后跟提交说明的方式，在一行命令中提交更新：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ git commit -m <span class="string">"Story 182: Fix benchmarks for speed"</span></span><br><span class="line">[master]: created 463dc4f: <span class="string">"Fix benchmarks for speed"</span></span><br><span class="line"> 2 files changed, 3 insertions(+), 0 deletions(-)</span><br><span class="line"> create mode 100644 README</span><br></pre></td></tr></table></figure></p>
<p>好，现在你已经创建了第一个提交！可以看到，提交后它会告诉你，当前是在哪个分支（master）提交的，本次提交的完整 SHA-1 校验和是什么（463dc4f），以及在本次提交中，有多少文件修订过，多少行添改和删改过。</p>
<p>记住，提交时记录的是放在暂存区域的快照，任何还未暂存的仍然保持已修改状态，可以在下次提交时纳入版本管理。每一次运行提交操作，都是对你项目作一次快照，以后可以回到这个状态，或者进行比较。</p>
<p>跳过使用暂存区域<br>尽管使用暂存区域的方式可以精心准备要提交的细节，但有时候这么做略显繁琐。Git 提供了一个跳过使用暂存区域的方式，只要在提交的时候，给 git commit 加上 -a 选项，Git 就会自动把所有已经跟踪过的文件暂存起来一并提交，从而跳过 git add步骤：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$ git status</span><br><span class="line"><span class="comment"># On branch master</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># Changes not staged for commit:</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">#   modified:   benchmarks.rb</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line">$ git commit <span class="_">-a</span> -m <span class="string">'added new benchmarks'</span></span><br><span class="line">[master 83e38c7] added new benchmarks</span><br><span class="line"> 1 files changed, 5 insertions(+), 0 deletions(-)</span><br></pre></td></tr></table></figure></p>
<p>看到了吗？提交之前不再需要 git add 文件 benchmarks.rb 了。</p>
<p>移除文件<br>要从 Git 中移除某个文件，就必须要从已跟踪文件清单中移除（确切地说，是从暂存区域移除），然后提交。可以用 git rm 命令完成此项工作，并连带从工作目录中删除指定的文件，这样以后就不会出现在未跟踪文件清单中了。</p>
<p>如果只是简单地从工作目录中手工删除文件，运行 git status 时就会在 “Changes not staged for commit” 部分（也就是<em>未暂存</em>清单）看到：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ rm grit.gemspec</span><br><span class="line">$ git status</span><br><span class="line"><span class="comment"># On branch master</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># Changes not staged for commit:</span></span><br><span class="line"><span class="comment">#   (use "git add/rm &lt;file&gt;..." to update what will be committed)</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">#       deleted:    grit.gemspec</span></span><br><span class="line"><span class="comment">#</span></span><br></pre></td></tr></table></figure></p>
<p>然后再运行 git rm 记录此次移除文件的操作：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$ git rm grit.gemspec</span><br><span class="line">rm <span class="string">'grit.gemspec'</span></span><br><span class="line">$ git status</span><br><span class="line"><span class="comment"># On branch master</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># Changes to be committed:</span></span><br><span class="line"><span class="comment">#   (use "git reset HEAD &lt;file&gt;..." to unstage)</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">#       deleted:    grit.gemspec</span></span><br><span class="line"><span class="comment">#</span></span><br></pre></td></tr></table></figure></p>
<p>最后提交的时候，该文件就不再纳入版本管理了。如果删除之前修改过并且已经放到暂存区域的话，则必须要用强制删除选项-f（译注：即 force 的首字母），以防误删除文件后丢失修改的内容。</p>
<p>另外一种情况是，我们想把文件从 Git 仓库中删除（亦即从暂存区域移除），但仍然希望保留在当前工作目录中。换句话说，仅是从跟踪清单中删除。比如一些大型日志文件或者一堆 .a 编译文件，不小心纳入仓库后，要移除跟踪但不删除文件，以便稍后在.gitignore 文件中补上，用 –cached 选项即可：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git rm --cached readme.txt</span><br></pre></td></tr></table></figure></p>
<p>后面可以列出文件或者目录的名字，也可以使用 glob 模式。比方说：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git rm <span class="built_in">log</span>/\*.log</span><br></pre></td></tr></table></figure></p>
<p>注意到星号 * 之前的反斜杠 \，因为 Git 有它自己的文件模式扩展匹配方式，所以我们不用 shell 来帮忙展开（译注：实际上不加反斜杠也可以运行，只不过按照 shell 扩展的话，仅仅删除指定目录下的文件而不会递归匹配。上面的例子本来就指定了目录，所以效果等同，但下面的例子就会用递归方式匹配，所以必须加反斜杠。）。此命令删除所有 log/ 目录下扩展名为 .log的文件。类似的比如：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git rm \*~</span><br></pre></td></tr></table></figure></p>
<p>会递归删除当前目录及其子目录中所有 ~ 结尾的文件。</p>
<p>移动文件<br>不像其他的 VCS 系统，Git 并不跟踪文件移动操作。如果在 Git 中重命名了某个文件，仓库中存储的元数据并不会体现出这是一次改名操作。不过 Git 非常聪明，它会推断出究竟发生了什么，至于具体是如何做到的，我们稍后再谈。</p>
<p>既然如此，当你看到 Git 的 mv 命令时一定会困惑不已。要在 Git 中对文件改名，可以这么做：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git mv file_from file_to</span><br></pre></td></tr></table></figure></p>
<p>它会恰如预期般正常工作。实际上，即便此时查看状态信息，也会明白无误地看到关于重命名操作的说明：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$ git mv README.txt README</span><br><span class="line">$ git status</span><br><span class="line"><span class="comment"># On branch master</span></span><br><span class="line"><span class="comment"># Your branch is ahead of 'origin/master' by 1 commit.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># Changes to be committed:</span></span><br><span class="line"><span class="comment">#   (use "git reset HEAD &lt;file&gt;..." to unstage)</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">#       renamed:    README.txt -&gt; README</span></span><br><span class="line"><span class="comment">#</span></span><br></pre></td></tr></table></figure></p>
<p>其实，运行 git mv 就相当于运行了下面三条命令：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ mv README.txt README</span><br><span class="line">$ git rm README.txt</span><br><span class="line">$ git add README</span><br></pre></td></tr></table></figure></p>
<p>如此分开操作，Git 也会意识到这是一次改名，所以不管何种方式都一样。当然，直接用 git mv 轻便得多，不过有时候用其他工具批处理改名的话，要记得在提交前删除老的文件名，再添加新的文件名。</p>
<p>查看提交历史<br>在提交了若干更新之后，又或者克隆了某个项目，想回顾下提交历史，可以使用 git log 命令查看。</p>
<p>接下来的例子会用我专门用于演示的 simplegit 项目，运行下面的命令获取该项目源代码：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> git://github.com/schacon/simplegit-progit.git</span><br></pre></td></tr></table></figure></p>
<p>然后在此项目中运行 git log，应该会看到下面的输出：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">$ git <span class="built_in">log</span></span><br><span class="line">commit ca82a6dff817ec66f44342007202690a93763949</span><br><span class="line">Author: Scott Chacon &lt;schacon@gee-mail.com&gt;</span><br><span class="line">Date:   Mon Mar 17 21:52:11 2008 -0700</span><br><span class="line"></span><br><span class="line">    changed the version number</span><br><span class="line"></span><br><span class="line">commit 085bb3bcb608e1e8451d4b2432f8ecbe6306e7e7</span><br><span class="line">Author: Scott Chacon &lt;schacon@gee-mail.com&gt;</span><br><span class="line">Date:   Sat Mar 15 16:40:33 2008 -0700</span><br><span class="line"></span><br><span class="line">    removed unnecessary <span class="built_in">test</span> code</span><br><span class="line"></span><br><span class="line">commit a11bef06a3f659402fe7563abf99ad00de2209e6</span><br><span class="line">Author: Scott Chacon &lt;schacon@gee-mail.com&gt;</span><br><span class="line">Date:   Sat Mar 15 10:31:28 2008 -0700</span><br><span class="line"></span><br><span class="line">    first commit</span><br></pre></td></tr></table></figure></p>
<p>默认不用任何参数的话，git log 会按提交时间列出所有的更新，最近的更新排在最上面。看到了吗，每次更新都有一个 SHA-1 校验和、作者的名字和电子邮件地址、提交时间，最后缩进一个段落显示提交说明。</p>
<p>git log 有许多选项可以帮助你搜寻感兴趣的提交，接下来我们介绍些最常用的。</p>
<p>我们常用 -p 选项展开显示每次提交的内容差异，用 -2 则仅显示最近的两次更新：</p>
<p>$ git log -p -2<br>commit ca82a6dff817ec66f44342007202690a93763949<br>Author: Scott Chacon <a href="&#109;&#x61;&#105;&#108;&#x74;&#x6f;&#58;&#x73;&#99;&#104;&#97;&#x63;&#x6f;&#x6e;&#64;&#x67;&#x65;&#x65;&#x2d;&#109;&#97;&#x69;&#x6c;&#x2e;&#x63;&#111;&#109;">&#x73;&#99;&#104;&#97;&#x63;&#x6f;&#x6e;&#64;&#x67;&#x65;&#x65;&#x2d;&#109;&#97;&#x69;&#x6c;&#x2e;&#x63;&#111;&#109;</a><br>Date:   Mon Mar 17 21:52:11 2008 -0700<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">    changed the version number</span><br><span class="line"></span><br><span class="line">diff --git a/Rakefile b/Rakefile</span><br><span class="line">index a874b73..8f94139 100644</span><br><span class="line">--- a/Rakefile</span><br><span class="line">+++ b/Rakefile</span><br><span class="line">@@ -5,7 +5,7 @@ require <span class="string">'rake/gempackagetask'</span></span><br><span class="line"> spec = Gem::Specification.new <span class="keyword">do</span> |s|</span><br><span class="line">-    s.version   =   <span class="string">"0.1.0"</span></span><br><span class="line">+    s.version   =   <span class="string">"0.1.1"</span></span><br><span class="line">     s.author    =   <span class="string">"Scott Chacon"</span></span><br></pre></td></tr></table></figure></p>
<p>commit 085bb3bcb608e1e8451d4b2432f8ecbe6306e7e7<br>Author: Scott Chacon <a href="&#109;&#97;&#105;&#x6c;&#116;&#111;&#x3a;&#115;&#99;&#x68;&#x61;&#99;&#x6f;&#110;&#64;&#103;&#x65;&#101;&#45;&#x6d;&#97;&#x69;&#108;&#46;&#99;&#x6f;&#109;">&#115;&#99;&#x68;&#x61;&#99;&#x6f;&#110;&#64;&#103;&#x65;&#101;&#45;&#x6d;&#97;&#x69;&#108;&#46;&#99;&#x6f;&#109;</a><br>Date:   Sat Mar 15 16:40:33 2008 -0700<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">removed unnecessary <span class="built_in">test</span> code</span><br></pre></td></tr></table></figure></p>
<p>diff –git a/lib/simplegit.rb b/lib/simplegit.rb<br>index a0a60ae..47c6340 100644<br>— a/lib/simplegit.rb<br>+++ b/lib/simplegit.rb<br>@@ -18,8 +18,3 @@ class SimpleGit<br>     end</p>
<p> end<br>-<br>-if $0 == <strong>FILE</strong></p>
<ul>
<li>git = SimpleGit.new</li>
<li>puts git.show<br>-end<br>\ No newline at end of file<br>在做代码审查，或者要快速浏览其他协作者提交的更新都作了哪些改动时，就可以用这个选项。此外，还有许多摘要选项可以用，比如 –stat，仅显示简要的增改行数统计：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">$ git <span class="built_in">log</span> --stat </span><br><span class="line">commit ca82a6dff817ec66f44342007202690a93763949</span><br><span class="line">Author: Scott Chacon &lt;schacon@gee-mail.com&gt;</span><br><span class="line">Date:   Mon Mar 17 21:52:11 2008 -0700</span><br><span class="line"></span><br><span class="line">    changed the version number</span><br><span class="line"></span><br><span class="line"> Rakefile |    2 +-</span><br><span class="line"> 1 files changed, 1 insertions(+), 1 deletions(-)</span><br><span class="line"></span><br><span class="line">commit 085bb3bcb608e1e8451d4b2432f8ecbe6306e7e7</span><br><span class="line">Author: Scott Chacon &lt;schacon@gee-mail.com&gt;</span><br><span class="line">Date:   Sat Mar 15 16:40:33 2008 -0700</span><br><span class="line"></span><br><span class="line">    removed unnecessary <span class="built_in">test</span> code</span><br><span class="line"></span><br><span class="line"> lib/simplegit.rb |    5 -----</span><br><span class="line"> 1 files changed, 0 insertions(+), 5 deletions(-)</span><br><span class="line"></span><br><span class="line">commit a11bef06a3f659402fe7563abf99ad00de2209e6</span><br><span class="line">Author: Scott Chacon &lt;schacon@gee-mail.com&gt;</span><br><span class="line">Date:   Sat Mar 15 10:31:28 2008 -0700</span><br><span class="line"></span><br><span class="line">    first commit</span><br><span class="line"></span><br><span class="line"> README           |    6 ++++++</span><br><span class="line"> Rakefile         |   23 +++++++++++++++++++++++</span><br><span class="line"> lib/simplegit.rb |   25 +++++++++++++++++++++++++</span><br><span class="line"> 3 files changed, 54 insertions(+), 0 deletions(-)</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>每个提交都列出了修改过的文件，以及其中添加和移除的行数，并在最后列出所有增减行数小计。还有个常用的 –pretty 选项，可以指定使用完全不同于默认格式的方式展示提交历史。比如用 oneline 将每个提交放在一行显示，这在提交数很大时非常有用。另外还有 short，full 和 fuller 可以用，展示的信息或多或少有些不同，请自己动手实践一下看看效果如何。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ git <span class="built_in">log</span> --pretty=oneline</span><br><span class="line">ca82a6dff817ec66f44342007202690a93763949 changed the version number</span><br><span class="line">085bb3bcb608e1e8451d4b2432f8ecbe6306e7e7 removed unnecessary <span class="built_in">test</span> code</span><br><span class="line">a11bef06a3f659402fe7563abf99ad00de2209e6 first commit</span><br></pre></td></tr></table></figure></p>
<p>但最有意思的是 format，可以定制要显示的记录格式，这样的输出便于后期编程提取分析，像这样：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ git <span class="built_in">log</span> --pretty=format:<span class="string">"%h - %an, %ar : %s"</span></span><br><span class="line">ca82a6d - Scott Chacon, 11 months ago : changed the version number</span><br><span class="line">085bb3b - Scott Chacon, 11 months ago : removed unnecessary <span class="built_in">test</span> code</span><br><span class="line">a11bef0 - Scott Chacon, 11 months ago : first commit</span><br></pre></td></tr></table></figure></p>
<p>表 2-1 列出了常用的格式占位符写法及其代表的意义。</p>
<p>选项   说明<br>%H  提交对象（commit）的完整哈希字串<br>%h  提交对象的简短哈希字串<br>%T  树对象（tree）的完整哈希字串<br>%t  树对象的简短哈希字串<br>%P  父对象（parent）的完整哈希字串<br>%p  父对象的简短哈希字串<br>%an 作者（author）的名字<br>%ae 作者的电子邮件地址<br>%ad 作者修订日期（可以用 -date= 选项定制格式）<br>%ar 作者修订日期，按多久以前的方式显示<br>%cn 提交者(committer)的名字<br>%ce 提交者的电子邮件地址<br>%cd 提交日期<br>%cr 提交日期，按多久以前的方式显示<br>%s  提交说明<br>你一定奇怪<em>作者（author）</em>和<em>提交者（committer）</em>之间究竟有何差别，其实作者指的是实际作出修改的人，提交者指的是最后将此工作成果提交到仓库的人。所以，当你为某个项目发布补丁，然后某个核心成员将你的补丁并入项目时，你就是作者，而那个核心成员就是提交者。我们会在第五章再详细介绍两者之间的细微差别。</p>
<p>用 oneline 或 format 时结合 –graph 选项，可以看到开头多出一些 ASCII 字符串表示的简单图形，形象地展示了每个提交所在的分支及其分化衍合情况。在我们之前提到的 Grit 项目仓库中可以看到：</p>
<p>$ git log –pretty=format:”%h %s” –graph</p>
<ul>
<li>2d3acf9 ignore errors from SIGCHLD on trap</li>
<li>5e3ee11 Merge branch ‘master’ of git://github.com/dustin/grit<br>|\<br>| * 420eac9 Added a method for getting the current branch.</li>
<li>| 30e367c timeout code and tests</li>
<li>| 5a09431 add timeout protection to grit</li>
<li>| e1193f8 support for heads with slashes in them<br>|/</li>
<li>d6016bc require time for xmlschema</li>
<li>11d191e Merge branch ‘defunkt’ into local<br>以上只是简单介绍了一些 git log 命令支持的选项。表 2-2 还列出了一些其他常用的选项及其释义。</li>
</ul>
<p>选项  说明<br>-p  按补丁格式显示每个更新之间的差异。<br>–stat  显示每次更新的文件修改统计信息。<br>–shortstat 只显示 –stat 中最后的行数修改添加移除统计。<br>–name-only 仅在提交信息后显示已修改的文件清单。<br>–name-status   显示新增、修改、删除的文件清单。<br>–abbrev-commit 仅显示 SHA-1 的前几个字符，而非所有的 40 个字符。<br>–relative-date 使用较短的相对时间显示（比如，“2 weeks ago”）。<br>–graph 显示 ASCII 图形表示的分支合并历史。<br>–pretty    使用其他格式显示历史提交信息。可用的选项包括 oneline，short，full，fuller 和 format（后跟指定格式）。<br>限制输出长度<br>除了定制输出格式的选项之外，git log 还有许多非常实用的限制输出长度的选项，也就是只输出部分提交信息。之前我们已经看到过 -2 了，它只显示最近的两条提交，实际上，这是 -<n> 选项的写法，其中的 n 可以是任何自然数，表示仅显示最近的若干条提交。不过实践中我们是不太用这个选项的，Git 在输出所有提交时会自动调用分页程序（less），要看更早的更新只需翻到下页即可。</n></p>
<p>另外还有按照时间作限制的选项，比如 –since 和 –until。下面的命令列出所有最近两周内的提交：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git <span class="built_in">log</span> --since=2.weeks</span><br></pre></td></tr></table></figure></p>
<p>你可以给出各种时间格式，比如说具体的某一天（“2008-01-15”），或者是多久以前（“2 years 1 day 3 minutes ago”）。</p>
<p>还可以给出若干搜索条件，列出符合的提交。用 –author 选项显示指定作者的提交，用 –grep 选项搜索提交说明中的关键字。（请注意，如果要得到同时满足这两个选项搜索条件的提交，就必须用 –all-match 选项。否则，满足任意一个条件的提交都会被匹配出来）</p>
<p>另一个真正实用的git log选项是路径(path)，如果只关心某些文件或者目录的历史提交，可以在 git log 选项的最后指定它们的路径。因为是放在最后位置上的选项，所以用两个短划线（–）隔开之前的选项和后面限定的路径名。</p>
<p>表 2-3 还列出了其他常用的类似选项。</p>
<p>选项  说明<br>-(n)    仅显示最近的 n 条提交<br>–since, –after    仅显示指定时间之后的提交。<br>–until, –before   仅显示指定时间之前的提交。<br>–author    仅显示指定作者相关的提交。<br>–committer 仅显示指定提交者相关的提交。<br>来看一个实际的例子，如果要查看 Git 仓库中，2008 年 10 月期间，Junio Hamano 提交的但未合并的测试脚本（位于项目的 t/ 目录下的文件），可以用下面的查询命令：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git <span class="built_in">log</span> --pretty=<span class="string">"%h - %s"</span> --author=gitster --since=<span class="string">"2008-10-01"</span> \</span><br><span class="line">   --before=<span class="string">"2008-11-01"</span> --no-merges -- t/</span><br></pre></td></tr></table></figure></p>
<p>5610e3b - Fix testcase failure when extended attribute<br>acd3b9e - Enhance hold_lock_file<em>for</em>{update,append}()<br>f563754 - demonstrate breakage of detached checkout wi<br>d1a43f2 - reset –hard/read-tree –reset -u: remove un<br>51a94af - Fix “checkout –track -b newbranch” on detac<br>b0ad11e - pull: allow “git pull origin $something:$cur<br>Git 项目有 20,000 多条提交，但我们给出搜索选项后，仅列出了其中满足条件的 6 条。</p>
<p>使用图形化工具查阅提交历史<br>有时候图形化工具更容易展示历史提交的变化，随 Git 一同发布的 gitk 就是这样一种工具。它是用 Tcl/Tk 写成的，基本上相当于git log 命令的可视化版本，凡是 git log 可以用的选项也都能用在 gitk 上。在项目工作目录中输入 gitk 命令后，就会启动图 2-2 所示的界面。</p>
<p>Insert 18333fig0202.png 图 2-2. gitk 的图形界面</p>
<p>上半个窗口显示的是历次提交的分支祖先图谱，下半个窗口显示当前点选的提交对应的具体差异。</p>
<p>撤消操作<br>任何时候，你都有可能需要撤消刚才所做的某些操作。接下来，我们会介绍一些基本的撤消操作相关的命令。请注意，有些撤销操作是不可逆的，所以请务必谨慎小心，一旦失误，就有可能丢失部分工作成果。</p>
<p>修改最后一次提交<br>有时候我们提交完了才发现漏掉了几个文件没有加，或者提交信息写错了。想要撤消刚才的提交操作，可以使用 –amend 选项重新提交：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git commit --amend</span><br></pre></td></tr></table></figure></p>
<p>此命令将使用当前的暂存区域快照提交。如果刚才提交完没有作任何改动，直接运行此命令的话，相当于有机会重新编辑提交说明，但将要提交的文件快照和之前的一样。</p>
<p>启动文本编辑器后，会看到上次提交时的说明，编辑它确认没问题后保存退出，就会使用新的提交说明覆盖刚才失误的提交。</p>
<p>如果刚才提交时忘了暂存某些修改，可以先补上暂存操作，然后再运行 –amend 提交：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git commit -m <span class="string">'initial commit'</span></span><br><span class="line">$ git add forgotten_file</span><br><span class="line">$ git commit --amend</span><br></pre></td></tr></table></figure></p>
<p>上面的三条命令最终只是产生一个提交，第二个提交命令修正了第一个的提交内容。</p>
<p>取消已经暂存的文件<br>接下来的两个小节将演示如何取消暂存区域中的文件，以及如何取消工作目录中已修改的文件。不用担心，查看文件状态的时候就提示了该如何撤消，所以不需要死记硬背。来看下面的例子，有两个修改过的文件，我们想要分开提交，但不小心用git add . 全加到了暂存区域。该如何撤消暂存其中的一个文件呢？其实，git status 的命令输出已经告诉了我们该怎么做：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ git add .</span><br><span class="line">$ git status</span><br><span class="line"><span class="comment"># On branch master</span></span><br><span class="line"><span class="comment"># Changes to be committed:</span></span><br><span class="line"><span class="comment">#   (use "git reset HEAD &lt;file&gt;..." to unstage)</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">#       modified:   README.txt</span></span><br><span class="line"><span class="comment">#       modified:   benchmarks.rb</span></span><br><span class="line"><span class="comment">#</span></span><br></pre></td></tr></table></figure></p>
<p>就在 “Changes to be committed” 下面，括号中有提示，可以使用 git reset HEAD <file>… 的方式取消暂存。好吧，我们来试试取消暂存 benchmarks.rb 文件：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">$ git reset HEAD benchmarks.rb</span><br><span class="line">benchmarks.rb: locally modified</span><br><span class="line">$ git status</span><br><span class="line"><span class="comment"># On branch master</span></span><br><span class="line"><span class="comment"># Changes to be committed:</span></span><br><span class="line"><span class="comment">#   (use "git reset HEAD &lt;file&gt;..." to unstage)</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">#       modified:   README.txt</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># Changes not staged for commit:</span></span><br><span class="line"><span class="comment">#   (use "git add &lt;file&gt;..." to update what will be committed)</span></span><br><span class="line"><span class="comment">#   (use "git checkout -- &lt;file&gt;..." to discard changes in working directory)</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">#       modified:   benchmarks.rb</span></span><br><span class="line"><span class="comment">#</span></span><br></pre></td></tr></table></figure></file></p>
<p>这条命令看起来有些古怪，先别管，能用就行。现在 benchmarks.rb 文件又回到了之前已修改未暂存的状态。</p>
<p>取消对文件的修改<br>如果觉得刚才对 benchmarks.rb 的修改完全没有必要，该如何取消修改，回到之前的状态（也就是修改之前的版本）呢？git status 同样提示了具体的撤消方法，接着上面的例子，现在未暂存区域看起来像这样：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Changes not staged for commit:</span></span><br><span class="line"><span class="comment">#   (use "git add &lt;file&gt;..." to update what will be committed)</span></span><br><span class="line"><span class="comment">#   (use "git checkout -- &lt;file&gt;..." to discard changes in working directory)</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">#       modified:   benchmarks.rb</span></span><br><span class="line"><span class="comment">#</span></span><br></pre></td></tr></table></figure></p>
<p>在第二个括号中，我们看到了抛弃文件修改的命令（至少在 Git 1.6.1 以及更高版本中会这样提示，如果你还在用老版本，我们强烈建议你升级，以获取最佳的用户体验），让我们试试看：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ git checkout -- benchmarks.rb</span><br><span class="line">$ git status</span><br><span class="line"><span class="comment"># On branch master</span></span><br><span class="line"><span class="comment"># Changes to be committed:</span></span><br><span class="line"><span class="comment">#   (use "git reset HEAD &lt;file&gt;..." to unstage)</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">#       modified:   README.txt</span></span><br><span class="line"><span class="comment">#</span></span><br></pre></td></tr></table></figure></p>
<p>可以看到，该文件已经恢复到修改前的版本。你可能已经意识到了，这条命令有些危险，所有对文件的修改都没有了，因为我们刚刚把之前版本的文件复制过来重写了此文件。所以在用这条命令前，请务必确定真的不再需要保留刚才的修改。如果只是想回退版本，同时保留刚才的修改以便将来继续工作，可以用下章介绍的 stashing 和分支来处理，应该会更好些。</p>
<p>记住，任何已经提交到 Git 的都可以被恢复。即便在已经删除的分支中的提交，或者用 –amend 重新改写的提交，都可以被恢复（关于数据恢复的内容见第九章）。所以，你可能失去的数据，仅限于没有提交过的，对 Git 来说它们就像从未存在过一样。</p>
<p>远程仓库的使用<br>要参与任何一个 Git 项目的协作，必须要了解该如何管理远程仓库。远程仓库是指托管在网络上的项目仓库，可能会有好多个，其中有些你只能读，另外有些可以写。同他人协作开发某个项目时，需要管理这些远程仓库，以便推送或拉取数据，分享各自的工作进展。管理远程仓库的工作，包括添加远程库，移除废弃的远程库，管理各式远程库分支，定义是否跟踪这些分支，等等。本节我们将详细讨论远程库的管理和使用。</p>
<p>查看当前的远程库<br>要查看当前配置有哪些远程仓库，可以用 git remote 命令，它会列出每个远程库的简短名字。在克隆完某个项目后，至少可以看到一个名为 origin 的远程库，Git 默认使用这个名字来标识你所克隆的原始仓库：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$ git <span class="built_in">clone</span> git://github.com/schacon/ticgit.git</span><br><span class="line">Initialized empty Git repository <span class="keyword">in</span> /private/tmp/ticgit/.git/</span><br><span class="line">remote: Counting objects: 595, done.</span><br><span class="line">remote: Compressing objects: 100% (269/269), done.</span><br><span class="line">remote: Total 595 (delta 255), reused 589 (delta 253)</span><br><span class="line">Receiving objects: 100% (595/595), 73.31 KiB | 1 KiB/s, done.</span><br><span class="line">Resolving deltas: 100% (255/255), done.</span><br><span class="line">$ <span class="built_in">cd</span> ticgit</span><br><span class="line">$ git remote</span><br><span class="line">origin</span><br></pre></td></tr></table></figure></p>
<p>也可以加上 -v 选项（译注：此为 –verbose 的简写，取首字母），显示对应的克隆地址：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git remote -v</span><br><span class="line">origin  git://github.com/schacon/ticgit.git</span><br></pre></td></tr></table></figure></p>
<p>如果有多个远程仓库，此命令将全部列出。比如在我的 Grit 项目中，可以看到：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">cd</span> grit</span><br><span class="line">$ git remote -v</span><br><span class="line">bakkdoor  git://github.com/bakkdoor/grit.git</span><br><span class="line">cho45     git://github.com/cho45/grit.git</span><br><span class="line">defunkt   git://github.com/defunkt/grit.git</span><br><span class="line">koke      git://github.com/koke/grit.git</span><br><span class="line">origin    git@github.com:mojombo/grit.git</span><br></pre></td></tr></table></figure></p>
<p>这样一来，我就可以非常轻松地从这些用户的仓库中，拉取他们的提交到本地。请注意，上面列出的地址只有 origin 用的是 SSH URL 链接，所以也只有这个仓库我能推送数据上去（我们会在第四章解释原因）。</p>
<p>添加远程仓库<br>要添加一个新的远程仓库，可以指定一个简单的名字，以便将来引用，运行 git remote add [shortname] [url]：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ git remote</span><br><span class="line">origin</span><br><span class="line">$ git remote add pb git://github.com/paulboone/ticgit.git</span><br><span class="line">$ git remote -v</span><br><span class="line">origin  git://github.com/schacon/ticgit.git</span><br><span class="line">pb  git://github.com/paulboone/ticgit.git</span><br></pre></td></tr></table></figure></p>
<p>现在可以用字符串 pb 指代对应的仓库地址了。比如说，要抓取所有 Paul 有的，但本地仓库没有的信息，可以运行git fetch pb：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ git fetch pb</span><br><span class="line">remote: Counting objects: 58, done.</span><br><span class="line">remote: Compressing objects: 100% (41/41), done.</span><br><span class="line">remote: Total 44 (delta 24), reused 1 (delta 0)</span><br><span class="line">Unpacking objects: 100% (44/44), done.</span><br><span class="line">From git://github.com/paulboone/ticgit</span><br><span class="line"> * [new branch]      master     -&gt; pb/master</span><br><span class="line"> * [new branch]      ticgit     -&gt; pb/ticgit</span><br></pre></td></tr></table></figure></p>
<p>现在，Paul 的主干分支（master）已经完全可以在本地访问了，对应的名字是 pb/master，你可以将它合并到自己的某个分支，或者切换到这个分支，看看有些什么有趣的更新。</p>
<p>从远程仓库抓取数据<br>正如之前所看到的，可以用下面的命令从远程仓库抓取数据到本地：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git fetch [remote-name]</span><br></pre></td></tr></table></figure></p>
<p>此命令会到远程仓库中拉取所有你本地仓库中还没有的数据。运行完成后，你就可以在本地访问该远程仓库中的所有分支，将其中某个分支合并到本地，或者只是取出某个分支，一探究竟。（我们会在第三章详细讨论关于分支的概念和操作。）</p>
<p>如果是克隆了一个仓库，此命令会自动将远程仓库归于 origin 名下。所以，git fetch origin 会抓取从你上次克隆以来别人上传到此远程仓库中的所有更新（或是上次 fetch 以来别人提交的更新）。有一点很重要，需要记住，fetch 命令只是将远端的数据拉到本地仓库，并不自动合并到当前工作分支，只有当你确实准备好了，才能手工合并。</p>
<p>如果设置了某个分支用于跟踪某个远端仓库的分支（参见下节及第三章的内容），可以使用 git pull 命令自动抓取数据下来，然后将远端分支自动合并到本地仓库中当前分支。在日常工作中我们经常这么用，既快且好。实际上，默认情况下 git clone 命令本质上就是自动创建了本地的 master 分支用于跟踪远程仓库中的 master 分支（假设远程仓库确实有 master 分支）。所以一般我们运行 git pull，目的都是要从原始克隆的远端仓库中抓取数据后，合并到工作目录中的当前分支。</p>
<p>推送数据到远程仓库<br>项目进行到一个阶段，要同别人分享目前的成果，可以将本地仓库中的数据推送到远程仓库。实现这个任务的命令很简单：git push [remote-name] [branch-name]。如果要把本地的 master 分支推送到 origin 服务器上（再次说明下，克隆操作会自动使用默认的 master 和 origin 名字），可以运行下面的命令：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git push origin master</span><br></pre></td></tr></table></figure></p>
<p>只有在所克隆的服务器上有写权限，或者同一时刻没有其他人在推数据，这条命令才会如期完成任务。如果在你推数据前，已经有其他人推送了若干更新，那你的推送操作就会被驳回。你必须先把他们的更新抓取到本地，合并到自己的项目中，然后才可以再次推送。有关推送数据到远程仓库的详细内容见第三章。</p>
<p>查看远程仓库信息<br>我们可以通过命令 git remote show [remote-name] 查看某个远程仓库的详细信息，比如要看所克隆的 origin 仓库，可以运行：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ git remote show origin</span><br><span class="line">* remote origin</span><br><span class="line">  URL: git://github.com/schacon/ticgit.git</span><br><span class="line">  Remote branch merged with <span class="string">'git pull'</span> <span class="keyword">while</span> on branch master</span><br><span class="line">    master</span><br><span class="line">  Tracked remote branches</span><br><span class="line">    master</span><br><span class="line">    ticgit</span><br></pre></td></tr></table></figure></p>
<p>除了对应的克隆地址外，它还给出了许多额外的信息。它友善地告诉你如果是在 master 分支，就可以用 git pull 命令抓取数据合并到本地。另外还列出了所有处于跟踪状态中的远端分支。</p>
<p>上面的例子非常简单，而随着使用 Git 的深入，git remote show 给出的信息可能会像这样：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">$ git remote show origin</span><br><span class="line">* remote origin</span><br><span class="line">  URL: git@github.com:defunkt/github.git</span><br><span class="line">  Remote branch merged with <span class="string">'git pull'</span> <span class="keyword">while</span> on branch issues</span><br><span class="line">    issues</span><br><span class="line">  Remote branch merged with <span class="string">'git pull'</span> <span class="keyword">while</span> on branch master</span><br><span class="line">    master</span><br><span class="line">  New remote branches (next fetch will store <span class="keyword">in</span> remotes/origin)</span><br><span class="line">    caching</span><br><span class="line">  Stale tracking branches (use <span class="string">'git remote prune'</span>)</span><br><span class="line">    libwalker</span><br><span class="line">    walker2</span><br><span class="line">  Tracked remote branches</span><br><span class="line">    acl</span><br><span class="line">    apiv2</span><br><span class="line">    dashboard2</span><br><span class="line">    issues</span><br><span class="line">    master</span><br><span class="line">    postgres</span><br><span class="line">  Local branch pushed with <span class="string">'git push'</span></span><br><span class="line">    master:master</span><br></pre></td></tr></table></figure></p>
<p>它告诉我们，运行 git push 时缺省推送的分支是什么（译注：最后两行）。它还显示了有哪些远端分支还没有同步到本地（译注：第六行的 caching 分支），哪些已同步到本地的远端分支在远端服务器上已被删除（译注：Stale tracking branches 下面的两个分支），以及运行 git pull 时将自动合并哪些分支（译注：前四行中列出的 issues 和 master 分支）。</p>
<p>远程仓库的删除和重命名<br>在新版 Git 中可以用 git remote rename 命令修改某个远程仓库在本地的简称，比如想把 pb 改成 paul，可以这么运行：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ git remote rename pb paul</span><br><span class="line">$ git remote</span><br><span class="line">origin</span><br><span class="line">paul</span><br><span class="line">注意，对远程仓库的重命名，也会使对应的分支名称发生变化，原来的 pb/master 分支现在成了 paul/master。</span><br></pre></td></tr></table></figure></p>
<p>碰到远端仓库服务器迁移，或者原来的克隆镜像不再使用，又或者某个参与者不再贡献代码，那么需要移除对应的远端仓库，可以运行 git remote rm 命令：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git remote rm paul</span><br><span class="line">$ git remote</span><br><span class="line">origin</span><br></pre></td></tr></table></figure></p>
<p>打标签<br>同大多数 VCS 一样，Git 也可以对某一时间点上的版本打上标签。人们在发布某个软件版本（比如 v1.0 等等）的时候，经常这么做。本节我们一起来学习如何列出所有可用的标签，如何新建标签，以及各种不同类型标签之间的差别。</p>
<p>列显已有的标签<br>列出现有标签的命令非常简单，直接运行 git tag 即可：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git tag</span><br><span class="line">v0.1</span><br><span class="line">v1.3</span><br></pre></td></tr></table></figure></p>
<p>显示的标签按字母顺序排列，所以标签的先后并不表示重要程度的轻重。</p>
<p>我们可以用特定的搜索模式列出符合条件的标签。在 Git 自身项目仓库中，有着超过 240 个标签，如果你只对 1.4.2 系列的版本感兴趣，可以运行下面的命令：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ git tag <span class="_">-l</span> <span class="string">'v1.4.2.*'</span></span><br><span class="line">v1.4.2.1</span><br><span class="line">v1.4.2.2</span><br><span class="line">v1.4.2.3</span><br><span class="line">v1.4.2.4</span><br></pre></td></tr></table></figure></p>
<p>新建标签<br>Git 使用的标签有两种类型：轻量级的（lightweight）和含附注的（annotated）。轻量级标签就像是个不会变化的分支，实际上它就是个指向特定提交对象的引用。而含附注标签，实际上是存储在仓库中的一个独立对象，它有自身的校验和信息，包含着标签的名字，电子邮件地址和日期，以及标签说明，标签本身也允许使用 GNU Privacy Guard (GPG) 来签署或验证。一般我们都建议使用含附注型的标签，以便保留相关信息；当然，如果只是临时性加注标签，或者不需要旁注额外信息，用轻量级标签也没问题。</p>
<p>含附注的标签<br>创建一个含附注类型的标签非常简单，用 -a （译注：取 annotated 的首字母）指定标签名字即可：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ git tag <span class="_">-a</span> v1.4 -m <span class="string">'my version 1.4'</span></span><br><span class="line">$ git tag</span><br><span class="line">v0.1</span><br><span class="line">v1.3</span><br><span class="line">v1.4</span><br></pre></td></tr></table></figure></p>
<p>而 -m 选项则指定了对应的标签说明，Git 会将此说明一同保存在标签对象中。如果没有给出该选项，Git 会启动文本编辑软件供你输入标签说明。</p>
<p>可以使用 git show 命令查看相应标签的版本信息，并连同显示打标签时的提交对象。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">$ git show v1.4</span><br><span class="line">tag v1.4</span><br><span class="line">Tagger: Scott Chacon &lt;schacon@gee-mail.com&gt;</span><br><span class="line">Date:   Mon Feb 9 14:45:11 2009 -0800</span><br><span class="line"></span><br><span class="line">my version 1.4</span><br><span class="line">commit 15027957951b64cf874c3557a0f3547bd83b3ff6</span><br><span class="line">Merge: 4a447f7... a6b4c97...</span><br><span class="line">Author: Scott Chacon &lt;schacon@gee-mail.com&gt;</span><br><span class="line">Date:   Sun Feb 8 19:02:46 2009 -0800</span><br><span class="line"></span><br><span class="line">    Merge branch <span class="string">'experiment'</span></span><br></pre></td></tr></table></figure></p>
<p>我们可以看到在提交对象信息上面，列出了此标签的提交者和提交时间，以及相应的标签说明。</p>
<p>签署标签<br>如果你有自己的私钥，还可以用 GPG 来签署标签，只需要把之前的 -a 改为 -s （译注： 取 signed 的首字母）即可：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">$ git tag <span class="_">-s</span> v1.5 -m <span class="string">'my signed 1.5 tag'</span></span><br><span class="line">You need a passphrase to unlock the secret key <span class="keyword">for</span></span><br><span class="line">user: <span class="string">"Scott Chacon &lt;schacon@gee-mail.com&gt;"</span></span><br><span class="line">1024-bit DSA key, ID F721C45A, created 2009-02-09</span><br><span class="line">现在再运行 git show 会看到对应的 GPG 签名也附在其内：</span><br><span class="line"></span><br><span class="line">$ git show v1.5</span><br><span class="line">tag v1.5</span><br><span class="line">Tagger: Scott Chacon &lt;schacon@gee-mail.com&gt;</span><br><span class="line">Date:   Mon Feb 9 15:22:20 2009 -0800</span><br><span class="line"></span><br><span class="line">my signed 1.5 tag</span><br><span class="line">-----BEGIN PGP SIGNATURE-----</span><br><span class="line">Version: GnuPG v1.4.8 (Darwin)</span><br><span class="line"></span><br><span class="line">iEYEABECAAYFAkmQurIACgkQON3DxfchxFr5cACeIMN+ZxLKggJQf0QYiQBwgySN</span><br><span class="line">Ki0An2JeAVUCAiJ7Ox6ZEtK+NvZAj82/</span><br><span class="line">=WryJ</span><br><span class="line">-----END PGP SIGNATURE-----</span><br><span class="line">commit 15027957951b64cf874c3557a0f3547bd83b3ff6</span><br><span class="line">Merge: 4a447f7... a6b4c97...</span><br><span class="line">Author: Scott Chacon &lt;schacon@gee-mail.com&gt;</span><br><span class="line">Date:   Sun Feb 8 19:02:46 2009 -0800</span><br><span class="line"></span><br><span class="line">    Merge branch <span class="string">'experiment'</span></span><br></pre></td></tr></table></figure></p>
<p>稍后我们再学习如何验证已经签署的标签。</p>
<p>轻量级标签<br>轻量级标签实际上就是一个保存着对应提交对象的校验和信息的文件。要创建这样的标签，一个 -a，-s 或 -m 选项都不用，直接给出标签名字即可：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ git tag v1.4-lw</span><br><span class="line">$ git tag</span><br><span class="line">v0.1</span><br><span class="line">v1.3</span><br><span class="line">v1.4</span><br><span class="line">v1.4-lw</span><br><span class="line">v1.5</span><br></pre></td></tr></table></figure></p>
<p>现在运行 git show 查看此标签信息，就只有相应的提交对象摘要：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ git show v1.4-lw</span><br><span class="line">commit 15027957951b64cf874c3557a0f3547bd83b3ff6</span><br><span class="line">Merge: 4a447f7... a6b4c97...</span><br><span class="line">Author: Scott Chacon &lt;schacon@gee-mail.com&gt;</span><br><span class="line">Date:   Sun Feb 8 19:02:46 2009 -0800</span><br><span class="line"></span><br><span class="line">    Merge branch <span class="string">'experiment'</span></span><br></pre></td></tr></table></figure></p>
<p>验证标签<br>可以使用 git tag -v [tag-name] （译注：取 verify 的首字母）的方式验证已经签署的标签。此命令会调用 GPG 来验证签名，所以你需要有签署者的公钥，存放在 keyring 中，才能验证：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ git tag -v v1.4.2.1</span><br><span class="line">object 883653babd8ee7ea23e6a5c392bb739348b1eb61</span><br><span class="line"><span class="built_in">type</span> commit</span><br><span class="line">tag v1.4.2.1</span><br><span class="line">tagger Junio C Hamano &lt;junkio@cox.net&gt; 1158138501 -0700</span><br><span class="line"></span><br><span class="line">GIT 1.4.2.1</span><br></pre></td></tr></table></figure></p>
<p>Minor fixes since 1.4.2, including git-mv and git-http with alternates.<br>gpg: Signature made Wed Sep 13 02:08:25 2006 PDT using DSA key ID F3119B9A<br>gpg: Good signature from “Junio C Hamano <a href="&#109;&#x61;&#x69;&#x6c;&#x74;&#111;&#58;&#106;&#117;&#x6e;&#x6b;&#105;&#x6f;&#x40;&#99;&#111;&#120;&#46;&#110;&#x65;&#x74;">&#106;&#117;&#x6e;&#x6b;&#105;&#x6f;&#x40;&#99;&#111;&#120;&#46;&#110;&#x65;&#x74;</a>“<br>gpg:                 aka “[jpeg image of size 1513]”<br>Primary key fingerprint: 3565 2A26 2040 E066 C9A7  4A7D C0C6 D9A4 F311 9B9A<br>若是没有签署者的公钥，会报告类似下面这样的错误：</p>
<p>gpg: Signature made Wed Sep 13 02:08:25 2006 PDT using DSA key ID F3119B9A<br>gpg: Can’t check signature: public key not found<br>error: could not verify the tag ‘v1.4.2.1’<br>后期加注标签<br>你甚至可以在后期对早先的某次提交加注标签。比如在下面展示的提交历史中：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">$ git <span class="built_in">log</span> --pretty=oneline</span><br><span class="line">15027957951b64cf874c3557a0f3547bd83b3ff6 Merge branch <span class="string">'experiment'</span></span><br><span class="line">a6b4c97498bd301d84096da251c98a07c7723e65 beginning write support</span><br><span class="line">0d52aaab4479697da7686c15f77a3d64d9165190 one more thing</span><br><span class="line">6d52a271eda8725415634dd79daabbc4d9b6008e Merge branch <span class="string">'experiment'</span></span><br><span class="line">0b7434d86859cc7b8c3d5e1dddfed66ff742fcbc added a commit <span class="keyword">function</span></span><br><span class="line">4682c3261057305bdd616e23b64b0857d832627b added a todo file</span><br><span class="line">166ae0c4d3f420721acbb115cc33848dfcc2121a started write support</span><br><span class="line">9fceb02d0ae598e95dc970b74767f19372d61af8 updated rakefile</span><br><span class="line">964f16d36dfccde844893cac5b347e7b3d44abbc commit the todo</span><br><span class="line">8a5cbc430f1a9c3d00faaeffd07798508422908a updated readme</span><br></pre></td></tr></table></figure></p>
<p>我们忘了在提交 “updated rakefile” 后为此项目打上版本号 v1.2，没关系，现在也能做。只要在打标签的时候跟上对应提交对象的校验和（或前几位字符）即可：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git tag <span class="_">-a</span> v1.2 9fceb02</span><br></pre></td></tr></table></figure></p>
<p>可以看到我们已经补上了标签：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">$ git tag</span><br><span class="line">v0.1</span><br><span class="line">v1.2</span><br><span class="line">v1.3</span><br><span class="line">v1.4</span><br><span class="line">v1.4-lw</span><br><span class="line">v1.5</span><br><span class="line"></span><br><span class="line">$ git show v1.2</span><br><span class="line">tag v1.2</span><br><span class="line">Tagger: Scott Chacon &lt;schacon@gee-mail.com&gt;</span><br><span class="line">Date:   Mon Feb 9 15:32:16 2009 -0800</span><br><span class="line"></span><br><span class="line">version 1.2</span><br><span class="line">commit 9fceb02d0ae598e95dc970b74767f19372d61af8</span><br><span class="line">Author: Magnus Chacon &lt;mchacon@gee-mail.com&gt;</span><br><span class="line">Date:   Sun Apr 27 20:43:35 2008 -0700</span><br><span class="line"></span><br><span class="line">    updated rakefile</span><br><span class="line">...</span><br></pre></td></tr></table></figure></p>
<p>分享标签<br>默认情况下，git push 并不会把标签传送到远端服务器上，只有通过显式命令才能分享标签到远端仓库。其命令格式如同推送分支，运行 git push origin [tagname] 即可：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ git push origin v1.5</span><br><span class="line">Counting objects: 50, done.</span><br><span class="line">Compressing objects: 100% (38/38), done.</span><br><span class="line">Writing objects: 100% (44/44), 4.56 KiB, done.</span><br><span class="line">Total 44 (delta 18), reused 8 (delta 1)</span><br><span class="line">To git@github.com:schacon/simplegit.git</span><br><span class="line">* [new tag]         v1.5 -&gt; v1.5</span><br></pre></td></tr></table></figure></p>
<p>如果要一次推送所有本地新增的标签上去，可以使用 –tags 选项：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">$ git push origin --tags</span><br><span class="line">Counting objects: 50, done.</span><br><span class="line">Compressing objects: 100% (38/38), done.</span><br><span class="line">Writing objects: 100% (44/44), 4.56 KiB, done.</span><br><span class="line">Total 44 (delta 18), reused 8 (delta 1)</span><br><span class="line">To git@github.com:schacon/simplegit.git</span><br><span class="line"> * [new tag]         v0.1 -&gt; v0.1</span><br><span class="line"> * [new tag]         v1.2 -&gt; v1.2</span><br><span class="line"> * [new tag]         v1.4 -&gt; v1.4</span><br><span class="line"> * [new tag]         v1.4-lw -&gt; v1.4-lw</span><br><span class="line"> * [new tag]         v1.5 -&gt; v1.5</span><br></pre></td></tr></table></figure></p>
<p>现在，其他人克隆共享仓库或拉取数据同步后，也会看到这些标签。</p>
<p>技巧和窍门<br>在结束本章之前，我还想和大家分享一些 Git 使用的技巧和窍门。很多使用 Git 的开发者可能根本就没用过这些技巧，我们也不是说在读过本书后非得用这些技巧不可，但至少应该有所了解吧。说实话，有了这些小窍门，我们的工作可以变得更简单，更轻松，更高效。</p>
<p>自动补全<br>如果你用的是 Bash shell，可以试试看 Git 提供的自动补全脚本。下载 Git 的源代码，进入 contrib/completion 目录，会看到一个 git-completion.bash 文件。将此文件复制到你自己的用户主目录中（译注：按照下面的示例，还应改名加上点：cp git-completion.bash ~/.git-completion.bash），并把下面一行内容添加到你的 .bashrc 文件中：</p>
<p>source ~/.git-completion.bash<br>也可以为系统上所有用户都设置默认使用此脚本。Mac 上将此脚本复制到 /opt/local/etc/bash_completion.d 目录中，Linux 上则复制到 /etc/bash_completion.d/ 目录中。这两处目录中的脚本，都会在 Bash 启动时自动加载。</p>
<p>如果在 Windows 上安装了 msysGit，默认使用的 Git Bash 就已经配好了这个自动补全脚本，可以直接使用。</p>
<p>在输入 Git 命令的时候可以敲两次跳格键（Tab），就会看到列出所有匹配的可用命令建议：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git co&lt;tab&gt;&lt;tab&gt;</span><br><span class="line">commit config</span><br></pre></td></tr></table></figure></p>
<p>此例中，键入 git co 然后连按两次 Tab 键，会看到两个相关的建议（命令）<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">commit 和 config。继而输入 m&lt;tab&gt; 会自动完成git commit 命令的输入。</span><br></pre></td></tr></table></figure></p>
<p>命令的选项也可以用这种方式自动完成，其实这种情况更实用些。比如运行 git log 的时候忘了相关选项的名字，可以输入开头的几个字母，然后敲 Tab 键看看有哪些匹配的：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git <span class="built_in">log</span> -<span class="_">-s</span>&lt;tab&gt;</span><br><span class="line">--shortstat  --since=  --src-prefix=  --stat   --summary</span><br></pre></td></tr></table></figure></p>
<p>这个技巧不错吧，可以节省很多输入和查阅文档的时间。</p>
<p>Git 命令别名<br>Git 并不会推断你输入的几个字符将会是哪条命令，不过如果想偷懒，少敲几个命令的字符，可以用 git config 为命令设置别名。来看看下面的例子：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ git config --global alias.co checkout</span><br><span class="line">$ git config --global alias.br branch</span><br><span class="line">$ git config --global alias.ci commit</span><br><span class="line">$ git config --global alias.st status</span><br></pre></td></tr></table></figure></p>
<p>现在，如果要输入 git commit 只需键入 git ci 即可。而随着 Git 使用的深入，会有很多经常要用到的命令，遇到这种情况，不妨建个别名提高效率。</p>
<p>使用这种技术还可以创造出新的命令，比方说取消暂存文件时的输入比较繁琐，可以自己设置一下：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git config --global alias.unstage <span class="string">'reset HEAD --'</span></span><br></pre></td></tr></table></figure></p>
<p>这样一来，下面的两条命令完全等同：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git unstage fileA</span><br><span class="line">$ git reset HEAD fileA</span><br></pre></td></tr></table></figure></p>
<p>显然，使用别名的方式看起来更清楚。另外，我们还经常设置 last 命令：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git config --global alias.last <span class="string">'log -1 HEAD'</span></span><br></pre></td></tr></table></figure></p>
<p>然后要看最后一次的提交信息，就变得简单多了：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ git last</span><br><span class="line">commit 66938dae3329c7aebe598c2246a8e6af90d04646</span><br><span class="line">Author: Josh Goebel &lt;dreamer3@example.com&gt;</span><br><span class="line">Date:   Tue Aug 26 19:48:51 2008 +0800</span><br></pre></td></tr></table></figure></p>
<pre><code>test for current head
Signed-off-by: Scott Chacon &lt;schacon@example.com&gt;
</code></pre><p>可以看出，实际上 Git 只是简单地在命令中替换了你设置的别名。不过有时候我们希望运行某个外部命令，而非 Git 的子命令，这个好办，只需要在命令前加上 ! 就行。如果你自己写了些处理 Git 仓库信息的脚本的话，就可以用这种技术包装起来。作为演示，我们可以设置用 git visual 启动 gitk：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git config --global alias.visual <span class="string">'!gitk'</span></span><br></pre></td></tr></table></figure></p>
<p>小结<br>到目前为止，你已经学会了最基本的 Git 本地操作：创建和克隆仓库，做出修改，暂存并提交这些修改，以及查看所有历史修改记录。接下来，我们将学习 Git 的必杀技特性：分支模型。</p>
<p>更多git操作命令见：<a href="http://www.tuicool.com/articles/IRNZzur" target="_blank" rel="external">http://www.tuicool.com/articles/IRNZzur</a></p>
<h3 id="下面是pull过程中遇到的一些问题以及解决办法"><a href="#下面是pull过程中遇到的一些问题以及解决办法" class="headerlink" title="下面是pull过程中遇到的一些问题以及解决办法"></a>下面是pull过程中遇到的一些问题以及解决办法</h3><h4 id="Your-local-changes-to-the-following-files-would-be-overwritten-by-merge"><a href="#Your-local-changes-to-the-following-files-would-be-overwritten-by-merge" class="headerlink" title="Your local changes to the following files would be overwritten by merge"></a>Your local changes to the following files would be overwritten by merge</h4><p>error: Your local changes to the following files would be overwritten by merge:<br>Please, commit your changes or stash them before you can merge.</p>
<p><a href="http://blog.csdn.net/zwhfyy/article/details/8625228" target="_blank" rel="external">参考这里</a></p>
<p>如果希望保留生产服务器上所做的改动,仅仅并入新配置项, 处理方法如下:</p>
<p>git stash<br>git pull<br>git stash pop<br>然后可以使用git diff -w +文件名 来确认代码自动合并的情况.</p>
<p>反过来,如果希望用代码库中的文件完全覆盖本地工作版本. 方法如下:</p>
<p>git reset –hard<br>git pull<br>其中git reset是针对版本,如果想针对文件回退本地修改,使用</p>
<h4 id="untracked-working-tree-file"><a href="#untracked-working-tree-file" class="headerlink" title="untracked working tree file"></a>untracked working tree file</h4><p><a href="http://blog.csdn.net/sheismylife/article/details/7204345" target="_blank" rel="external">参考这里</a></p>
<p>编写脚本自动编译并部署时的注意</p>
<p>如果想在C2上编写脚本自动从S1上获取最新代码时，要注意：</p>
<p>1.首先之前产生的公钥不能设密码，否则每次git pull的时候都会要求输入密码。</p>
<p>2.不要将项目中的编译中间文件提交到S1上，比如CMake工程里面的build目录的文件，Maven工程里面的target目录里面的文件。否则下次在C2等客户端用git pull会报类似于这样的错误：</p>
<h4 id="error-Untracked-working-tree-file-‘public-images-icon-gif’-would-be-overwritten-by-merge"><a href="#error-Untracked-working-tree-file-‘public-images-icon-gif’-would-be-overwritten-by-merge" class="headerlink" title="error: Untracked working tree file ‘public/images/icon.gif’ would be overwritten by merge."></a>error: Untracked working tree file ‘public/images/icon.gif’ would be overwritten by merge.</h4><p>需要执行下面的命令才能修复：</p>
<p>git reset –hard HEAD<br>git clean -f -d<br>git pull  </p>

      
    </div>
    
    <div>
      
        
      
    </div>

    <div>
      
        
      
    </div>

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/Git/" rel="tag">#Git</a>
          
        </div>
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2016/04/07/hello-world/" rel="next" title="Hello World">
                <i class="fa fa-chevron-left"></i> Hello World
              </a>
            
          </div>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2016/04/12/大创总结/" rel="prev" title="大创总结">
                大创总结 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          
  <div class="comments" id="comments">
    
      <div class="ds-thread" data-thread-key="2016/04/08/Git基础/"
           data-title="Git基础" data-url="http://hujun1413.github.io/2016/04/08/Git基础/">
      </div>
    
  </div>


        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap" >
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview sidebar-panel ">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="http://ofl6ycl3e.bkt.clouddn.com/avatar.png"
               alt="hujun1413" />
          <p class="site-author-name" itemprop="name">hujun1413</p>
          <p class="site-description motion-element" itemprop="description">轻吟浅唱，我在岁月中踽踽独行</p>
        </div>
        <nav class="site-state motion-element">
          <div class="site-state-item site-state-posts">
            <a href="/archives">
              <span class="site-state-item-count">37</span>
              <span class="site-state-item-name">日志</span>
            </a>
          </div>

          
            <div class="site-state-item site-state-categories">
              <a href="/categories">
                <span class="site-state-item-count">15</span>
                <span class="site-state-item-name">分类</span>
              </a>
            </div>
          

          
            <div class="site-state-item site-state-tags">
              <a href="/tags">
                <span class="site-state-item-count">23</span>
                <span class="site-state-item-name">标签</span>
              </a>
            </div>
          

        </nav>

        
          <div class="feed-link motion-element">
            <a href="/atom.xml" rel="alternate">
              <i class="fa fa-rss"></i>
              RSS
            </a>
          </div>
        

        <div class="links-of-author motion-element">
          
        </div>

        
        

        
        <div class="links-of-blogroll motion-element">
          
            <div class="links-of-blogroll-title">友情链接</div>
            <ul class="links-of-blogroll-list">
              
                <li class="links-of-blogroll-item">
                  <a href="http://github.com/hujun1413" target="_blank">我的GitHub</a>
                </li>
              
                <li class="links-of-blogroll-item">
                  <a href="http://blog.csdn.net/hujun1994" target="_blank">我的CSDN</a>
                </li>
              
                <li class="links-of-blogroll-item">
                  <a href="http://weibo.com/2918019673" target="_blank">我的微博</a>
                </li>
              
            </ul>
          
        </div>

      </section>

      
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">
            
              
            
            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#本地管理"><span class="nav-number">1.</span> <span class="nav-text">本地管理</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#创建版本库"><span class="nav-number">1.1.</span> <span class="nav-text">创建版本库</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#版本回退"><span class="nav-number">1.2.</span> <span class="nav-text">版本回退</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#管理修改"><span class="nav-number">1.3.</span> <span class="nav-text">管理修改</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#删除文件"><span class="nav-number">1.4.</span> <span class="nav-text">删除文件</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#远程仓库"><span class="nav-number">2.</span> <span class="nav-text">远程仓库</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#添加远程库"><span class="nav-number">2.1.</span> <span class="nav-text">添加远程库</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#从远程库克隆"><span class="nav-number">2.2.</span> <span class="nav-text">从远程库克隆</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#创建-合并-删除分支"><span class="nav-number">2.3.</span> <span class="nav-text">创建/合并/删除分支</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#解决冲突"><span class="nav-number">2.4.</span> <span class="nav-text">解决冲突</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#对比差异"><span class="nav-number">2.5.</span> <span class="nav-text">对比差异</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#fetch"><span class="nav-number">2.6.</span> <span class="nav-text">fetch</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#pull"><span class="nav-number">2.7.</span> <span class="nav-text">pull</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#push"><span class="nav-number">2.8.</span> <span class="nav-text">push</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#remote"><span class="nav-number">2.9.</span> <span class="nav-text">remote</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#删除远程的提交记录"><span class="nav-number">2.10.</span> <span class="nav-text">删除远程的提交记录</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#其他"><span class="nav-number">2.11.</span> <span class="nav-text">其他</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#下面是pull过程中遇到的一些问题以及解决办法"><span class="nav-number">2.12.</span> <span class="nav-text">下面是pull过程中遇到的一些问题以及解决办法</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Your-local-changes-to-the-following-files-would-be-overwritten-by-merge"><span class="nav-number">2.12.1.</span> <span class="nav-text">Your local changes to the following files would be overwritten by merge</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#untracked-working-tree-file"><span class="nav-number">2.12.2.</span> <span class="nav-text">untracked working tree file</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#error-Untracked-working-tree-file-‘public-images-icon-gif’-would-be-overwritten-by-merge"><span class="nav-number">2.12.3.</span> <span class="nav-text">error: Untracked working tree file ‘public/images/icon.gif’ would be overwritten by merge.</span></a></li></ol></li></ol></li></ol></div>
            
          </div>
        </section>
      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy;  2016 - 
  <span itemprop="copyrightYear">2017</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">hujun1413</span>

   &nbsp;&nbsp;|&nbsp;&nbsp;
  <script type="text/javascript">var cnzz_protocol = (("https:" == document.location.protocol) ? " https://" : " http://");document.write(unescape("%3Cspan id='cnzz_stat_icon_1258400302'%3E%3C/span%3E%3Cscript src='" + cnzz_protocol + "s11.cnzz.com/z_stat.php%3Fid%3D1258400302' type='text/javascript'%3E%3C/script%3E"));</script>

  &nbsp;&nbsp;|&nbsp;&nbsp;<span><a href="/sitemap.xml">Google网站地图</a></span>
  &nbsp;&nbsp;|&nbsp;&nbsp;<span><a href="/baidusitemap.xml">百度网站地图</a></span>

  </span>
</div>

<div class="powered-by">
  由 <a class="theme-link" href="http://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Mist
  </a>
</div>

&nbsp;&nbsp;|&nbsp;&nbsp;本页点击 <span id="busuanzi_value_page_pv"></span> 次
&nbsp;&nbsp;|&nbsp;&nbsp;本站总点击 <span id="busuanzi_value_site_pv"></span> 次
&nbsp;&nbsp;|&nbsp;&nbsp;您是第 <span id="busuanzi_value_site_uv"></span> 位访客

<script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js">
</script>

<script>
(function(){
    var bp = document.createElement('script');
    bp.src = '//push.zhanzhang.baidu.com/push.js';
    var s = document.getElementsByTagName("script")[0];
    s.parentNode.insertBefore(bp, s);
})();
</script>



      </div>
    </footer>

    <div class="back-to-top">
      <i class="fa fa-arrow-up"></i>
    </div>
  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  



  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.0.1"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.0.1"></script>



  
  

  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.0.1"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.0.1"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.0.1"></script>



  

  
    
  

  <script type="text/javascript">
    var duoshuoQuery = {short_name:"hujun1413"};
    (function() {
      var ds = document.createElement('script');
      ds.type = 'text/javascript';ds.async = true;
      ds.id = 'duoshuo-script';
      ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
      ds.charset = 'UTF-8';
      (document.getElementsByTagName('head')[0]
      || document.getElementsByTagName('body')[0]).appendChild(ds);
    })();
  </script>

  
    
  





  
  
  

  

  

</body>
</html>
