---
title:  《Linux设备驱动程序》笔记
date: 2017-01-11 20:35:26 # 文章生成时间，一般不改
categories:   # 文章分类目录，参数可省略
    - OSLab
    - 驱动
tags:   # 文章标签，参数可省略

---
### 错误回复的处理有时使用goto语句比较有效
P38

[TOC]
<!--more-->

### [什么是Linux设备驱动程序](http://blog.csdn.net/yapingmcu/article/details/7400262)（P9）
linux驱动处于OS和硬件之间。
驱动给OS提供一组设备驱动接口函数（包括open,close,read,ioctl等）

### 为什么研究编写Linux驱动程序（P9）
* 新硬件问世或硬件过时
* 个人用户要了解一些驱动程序知识才能访问设备
* 硬件厂商通过提供Linux驱动程序能为自己的产品带来潜在用户群
* Linux开源，驱动程序源码可以在大量用户中迅速流传

### 设备驱动程序的作用（P10）
1. 驱动的作用在于提供机制，而不是提供策略（驱动灵活）
	* 机制：需要提供什么功能
	* 策略：如何使用这些功能
2. 介于应用程序和实际设备之间，设计驱动时综合考虑三方面：给用户提供尽可能多的选项，编写驱动占用的时间，尽量保持程序简单而不至于错误丛生
3. 不带策略的驱动的典型特征：同时支持同步和异步，能被多次打开，充分利用硬件特性，不具备用来“简化任务”的或提供与策略相关的软件层

### 内核功能划分（P12）
1. 进程管理：在单个或多个CPU上实现了多个进程的抽象
2. 内存管理：内核的不同部分在和内存管理子系统交互时使用一组函数调用
3. 文件系统：Linux支持多种文件系统类型，也就是在物理介质上组织数据的不同方式
4. 设备控制：除了处理器和内存等少数对象外，所有设备控制操作都由驱动完成
5. 网络功能：大部分网络操作和具体进程无关。系统负责在应用程序和网络接口之间传递数据包，并根据网络活动控制程序的执行。所有的路由和地址解析问题都由内核处理。

### 设备和模块的分类（P14）
1. 字符模块：能像字节流（类似文件）一样被访问的设备。字符设备驱动通常至少要实现open，close，read和write系统调用。
2. 块模块：每次只能传输一个或多个完整的块（512KB或更大），和字符驱动相比具有完全不同的接口。
3. 网络模块：网络接口可以是硬件设备，也可能是个纯软件设备（回环接口loopback）。只负责发送和接受数据包，eth0在文件系统中不存在对应的节点

### 驱动安全策略（P16）
* 系统中所有安全检查都是由内核代码进行的，系统调用init_module会检查调用进程是否具有将模块装载到内核的权利。
* 尽量避免在驱动代码中实现安全策略。由驱动本身完成的相关安全检查：能影响全局资源的设备操作（设置中断线），可能会破坏硬件（装载固件），影响其他用户（给磁盘驱动器设置默认的块尺寸），这些都只能由root执行

### 核心模块与应用程序的对比（P24）
* 内核模块都是事件驱动的，模块只是预先注册自己以便服务于将来的某个请求。
* 内核模块能调用的函数仅仅是由内核导出的那些函数，而不存在任何可链接的函数库。printk函数缺少对浮点数的支持。
* 处理错误的方式不同，应用程序中的段错误是无害的，总是可以使用调试器跟踪到源代码中的问题所在，而一个内核错误即使不影响整个系统，也至少会杀死当前进程。

### 用户空间和内核空间（P25）
* OS必须负责程序的独立操作并保护资源不受非法访问，在CPU中实现不同的操作模式（级别）。
* 当应用程序执行系统调用或者被硬件中断挂起时（两者由驱动代码提供），Unix将执行模式从用户空间切换到内核空间。执行系统调用的内核代码运行在进程上下文中，它代表调用进程执行操作，能访问进程地址空间的所有数据，而处理硬件中断的内核代码和进程是异步的，与特定进程无关。

### 内核中的并发（P26）
原因：
1. Linux系统中通常正在运行多个并发进程，并且可能有多个进程同时使用我们的驱动程序。
2. 大多数设备能够中断处理器，而且中断处理程序可能在驱动正试图处理其他任务时被调用。
3. 有一些软件抽象（如内核定时器）也在异步运行着。
4. Linux还可以运行对称多处理器(SMP)系统上，可能同时有不止一个CPU运行着驱动。
5. 内核代码是可抢占的，即使在单处理器系统上也存在类似多处理器系统的并发问题。

### 版本依赖（P31）
* 加载模块时会将模块与当前内核树中的vermagic.o链接，用来检查模块和正在运行的内核的兼容性。

### 内核符号表（P33）
* 模块被装入内核后，它所导出的任何符号都会变成内核符号表的一部分。
* EXPORT_SYMBOL_GPL(name)导出的模块只能被GPL许可证下的模块使用。这个宏将被扩展为一个全局变量的声明，该变量在模块可执行文件的ELF段中保存。

### 初始化和关闭
```bash
static int __init record_init_module(void)
static void __exit record_exit_module(void)
module_init(record_init_module);
module_exit(record_exit_module);
```
\_\_init表示仅在初始化使用；在模块装载结束后，模块装载器会将初始化函数扔掉。
```
#define __init __attribute__((__section__(".init.text")) __cold
```


### 小知识积累
* Unix图形显示器的管理分为X服务器+窗口和会话管理器
* 软驱的驱动程序不带策略，它的作用是将磁盘表示为一个连续的数据块阵列。系统高层提供策略
* 许多驱动是同用户程序一起发行的：比如，用来调整并口打印机驱动程序工作方式的tunelp程序；作为PCMCIA驱动程序包一部分的图形化cardctl工具。还会有一个客户程序库，它提供不必在驱动本身实现的功能
* 不同进程之间的通信方式：信号，管道，进程间通信原语
* 磁盘可以格式化为符合Linux标准的ext3文件系统，也可以格式化为常用的FAT文件系统或者其他种类
* 字符终端（/dev/console）和串口（/dev/ttys0以及类似设备）是字符设备。字符设备可以通过文件系统节点来访问，比如/dev/tty1和/dev/lp0。
* 偶数编号的内核版本（如2.6.x）是正式发行的稳定版本，而奇数编号的版本（如2.7.x）则是开发过程中的一个快照，将很快被下一个开发版本不同。
* 如何将内核内存映射到用户空间（即mmap系统调用），如何将用户内存映射到内核空间（即get_user_pages），如何将这两种内存映射到设备空间（执行DMA操作）
* 竞态问题：不同的执行顺序导致不同的，非预期行为发生。
* current是一个执行struct task_struct的指针，current隐藏在内核栈中，便于current被频繁引用。
* 内核具有很小的栈，可能只有一个4096字节大小的页那么小，我们自己的函数必须和整个内核空间调用链一同共享这个栈。
* insmod依赖于定义在kernel/module.c中的一个系统调用，函数sys_init_module给模块分配内核内存（vmalloc负责内存分配）
* 系统调用的名字前都带有sys_前缀
* modprobe也用来将模块加载到内核，但若模块引用了内核中不存在的符号时，它会在当前模块搜索路径（标准的已安装模块目录）中查找定义了这些符号的其他模块，并将这些模块也装载到内核。而insmod则会失败，提示"unresolved symbols"。
* lsmod读取sysfs虚拟文件系统中/proc/modules虚拟文件
* 查看系统日志文件（/var/log/messages或者系统配置使用的文件）
* IA-32（Intel Architecture 32 bit），常被称为i386,x86-32,x86。


























