---
title:  Python面向对象高级编程
date: 2016-12-19 20:35:26 # 文章生成时间，一般不改
categories:   # 文章分类目录，参数可省略
    - 编程语言
    - Python
tags:   # 文章标签，参数可省略

---
[TOC]
### 使用\_\_slots\_\_
给实例绑定一个属性：
```python
>>> s = Student()
>>> s.name = 'Michael' # 动态给实例绑定一个属性
>>> print(s.name)
Michael
```
给实例绑定一个方法：
```python
>>> def set_age(self, age): # 定义一个函数作为实例方法
...     self.age = age
...
>>> from types import MethodType
>>> s.set_age = MethodType(set_age, s) # 给实例绑定一个方法
>>> s.set_age(25) # 调用实例方法
>>> s.age # 测试结果
25
```
给一个实例绑定的方法，对另一个实例是不起作用的。
为了给所有实例都绑定方法，可以给class动态绑定方法：
```python
>>> def set_score(self, score):
...     self.score = score
...
>>> Student.set_score = set_score
```
上面的set_score方法可以直接定义在class中，这属于静态绑定，但动态绑定允许我们在程序运行的过程中动态给class加上功能。

#### 限制实例的属性
在定义class的时候，定义一个特殊的\_\_slots\_\_变量，来限制该class实例能添加的属性：
```python
class Student(object):
    __slots__ = ('name', 'age') # 用tuple定义允许绑定的属性名称

>>> s = Student() # 创建新的实例
>>> s.name = 'Michael' # 绑定属性'name'
>>> s.score = 99 # 绑定属性'score'
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
AttributeError: 'Student' object has no attribute 'score'
```
**要注意**:\_\_slots\_\_定义的属性仅对当前类实例起作用，对继承的子类是不起作用的：
```python
>>> class GraduateStudent(Student):
...     pass
...
>>> g = GraduateStudent()
>>> g.score = 9999
```
除非在子类中也定义__slots__，这样，子类实例允许定义的属性就是**自身的\_\_slots\_\_加上父类的\_\_slots\_\_**。

### 使用@property
有没有既能检查参数，又可以用类似属性这样简单的方式来访问类的变量呢？对于追求完美的Python程序员来说，这是必须要做到的！
Python内置的@property装饰器就是负责把一个方法变成属性调用的：
```python
class Student(object):

    @property
    def score(self):
        return self._score

    @score.setter
    def score(self, value):
        if not isinstance(value, int):
            raise ValueError('score must be an integer!')
        if value < 0 or value > 100:
            raise ValueError('score must between 0 ~ 100!')
        self._score = value
```
把一个getter方法变成属性，只需要加上@property就可以了。
@property本身又创建了另一个装饰器@score.setter，负责把一个setter方法变成属性赋值。
```python
>>> s = Student()
>>> s.score = 60 # OK，实际转化为s.set_score(60)
>>> s.score # OK，实际转化为s.get_score()
60
>>> s.score = 9999
Traceback (most recent call last):
  ...
ValueError: score must between 0 ~ 100!
```
还可以定义只读属性，只定义getter方法，不定义setter方法就是一个只读属性。

### 多重继承
对于需要Runnable功能的动物，就多继承一个Runnable，例如Dog：
```python
class Dog(Mammal, Runnable):
    pass
```

#### MixIn
让Ostrich除了继承自Bird外，再同时继承Runnable。这种设计通常称之为MixIn。
为了更好地看出继承关系，我们把Runnable和Flyable改为RunnableMixIn和FlyableMixIn。类似的，你还可以定义出肉食动物CarnivorousMixIn和植食动物HerbivoresMixIn，让某个动物同时拥有好几个MixIn：
```python
class Dog(Mammal, RunnableMixIn, CarnivorousMixIn):
    pass
```
MixIn的目的就是给一个类增加多个功能，这样，在设计类的时候，我们优先考虑通过多重继承来组合多个MixIn的功能，而不是设计多层次的复杂的继承关系。
这样一来，我们不需要复杂而庞大的继承链，只要选择组合不同的类的功能，就可以快速构造出所需的子类。
只允许单一继承的语言（如Java）不能使用MixIn的设计。

### 定制类
Python的class中还有许多这样有特殊用途的函数，可以帮助我们定制类。
#### \_\_str\_\_
打印一个实例更好看：
```python
>>> class Student(object):
...     def __init__(self, name):
...         self.name = name
...     def __str__(self):
...         return 'Student object (name: %s)' % self.name
...
>>> print(Student('Michael'))
Student object (name: Michael)
```
但直接敲变量不用print，打印出来的实例还是不好看：
```python
>>> s = Student('Michael')
>>> s
<__main__.Student object at 0x109afb310>
```
直接显示变量调用的不是\_\_str\_\_()，而是\_\_repr\_\_()，两者的区别是\_\_str\_\_()返回用户看到的字符串，而\_\_repr\_\_()返回程序开发者看到的字符串，也就是说，\_\_repr\_\_()是为调试服务的。
解决办法是再定义一个\_\_repr\_\_()。但是通常\_\_str\_\_()和\_\_repr\_\_()代码都是一样的，所以，有个偷懒的写法：
```python
__repr__ = __str__
```
#### \_\_iter\_\_
如果一个类想被用于for ... in循环，类似list或tuple那样，就必须实现一个__iter__()方法。
```python
class Fib(object):
    def __init__(self):
        self.a, self.b = 0, 1 # 初始化两个计数器a，b

    def __iter__(self):
        return self # 实例本身就是迭代对象，故返回自己

    def __next__(self):
        self.a, self.b = self.b, self.a + self.b # 计算下一个值
        if self.a > 100000: # 退出循环的条件
            raise StopIteration();
        return self.a # 返回下一个值
```

#### \_\_getitem\_\_
要表现得像list那样按照下标取出元素，需要实现__getitem__()方法：
```python
class Fib(object):
    def __getitem__(self, n):
        a, b = 1, 1
        for x in range(n):
            a, b = b, a + b
        return a
```
也可以实现切片，包括切片的step和负数处理。

如果把对象看成dict，\_\_getitem\_\_()的参数也可能是一个可以作key的object，例如str。

与之对应的是\_\_setitem\_\_()方法，把对象视作list或dict来对集合赋值。最后，还有一个\_\_delitem\_\_()方法，用于删除某个元素。

#### \_\_getattr\_\_
只有在没有找到属性的情况下，才调用__getattr__，已有的属性不会在__getattr__中查找。

注意到任意调用如s.abc都会返回None，这是因为我们定义的__getattr__默认返回就是None。要让class只响应特定的几个属性，我们就要按照约定，抛出AttributeError的错误：
```python
class Student(object):

    def __getattr__(self, attr):
        if attr=='age':
            return lambda: 25
        raise AttributeError('\'Student\' object has no attribute \'%s\'' % attr)
```

#### \_\_call\_\_
定义一个__call__()方法，就可以直接对实例进行调用。
```python
class Student(object):
    def __init__(self, name):
        self.name = name

    def __call__(self):
        print('My name is %s.' % self.name)

调用方式：
>>> s = Student('Michael')
>>> s() # self参数不要传入
My name is Michael.
```
__call__()还可以定义参数。

用callable()函数判断一个对象是否是“可调用”对象。
```python
>>> callable(max)
True
>>> callable([1, 2, 3])
False
```
这里的只是最常用的几个定制方法，还有很多可定制的方法，请参考[Python的官方文档](http://docs.python.org/3/reference/datamodel.html#special-method-names)。

作业：带users()的链式调用的实现
[【思考题的两种题解】带users()的链式调用的两种实现](http://www.liaoxuefeng.com/discuss/001409195742008d822b26cf3de46aea14f2b7378a1ba91000/0014805200242673d853035126c4bb78bbe4fc5f9930edf000)

### 使用枚举类
为枚举类型定义一个class类型，然后，每个常量都是class的一个唯一实例。Python提供了Enum类来实现这个功能：
```python
from enum import Enum

Month = Enum('Month', ('Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'))

>>> for name, member in Month.__members__.items():
...     print(name, '=>', member, ',', member.value)
...
Jan => Month.Jan , 1
Feb => Month.Feb , 2
Mar => Month.Mar , 3
Apr => Month.Apr , 4
May => Month.May , 5
Jun => Month.Jun , 6
Jul => Month.Jul , 7
Aug => Month.Aug , 8
Sep => Month.Sep , 9
Oct => Month.Oct , 10
Nov => Month.Nov , 11
Dec => Month.Dec , 12

```
alue属性则是自动赋给成员的int常量，默认从1开始计数。

需要更精确地控制枚举类型，可以从Enum派生出自定义类：

```python
>>> print(Weekday.Tue)
Weekday.Tue
>>> print(Weekday['Tue'])
Weekday.Tue
>>> print(Weekday.Tue.value)
2
>>> print(Weekday(2))
Weekday.Tue
```
既可以用成员名称引用枚举常量，又可以直接根据value的值获得枚举常量。

### 使用元类




















