---
title:  Python函数
date: 2016-12-28 20:35:26 # 文章生成时间，一般不改
categories:   # 文章分类目录，参数可省略
    - 编程语言
    - Python
tags:   # 文章标签，参数可省略

---
[TOC]
### 调用函数
```python
help(abs)  #查看abs()函数的帮助信息
abs(-6)
max(2,3,1,-5)
min(2,3)
int('123')
float('12.3')
str(100)
>>> bool(1)
True
>>> bool(-3)
True
>>> bool(0)
False
>>> bool('')
False
>>> bool("")
False
>>>
```
函数名其实就是指向一个函数对象的引用，完全可以把函数名赋给一个变量，相当于给这个函数起了一个“别名”：
```python
>>> a = abs # 变量a指向abs函数
>>> a(-1) # 所以也可以通过a调用abs函数
1
```

### 定义函数
```python
def my_abs(x):
    if not isinstance(x, (int, float)):
        raise TypeError('bad operand type')
    if x>=0:
    	return x
    else:
        return -x

存成pyTest.py
在该目录下执行:
>>> from pyTest import my_abs
>>> my_abs(-9)
9
```
如果没有return语句，函数执行完毕后也会返回结果，只是结果为None。

return None可以简写为return。

#### 空函数
```python
if age >= 18:
    pass
```
pass语句什么都不做，那有什么用？实际上pass可以用来作为占位符，比如现在还没想好怎么写函数的代码，就可以先放一个pass，让代码能运行起来。

#### 参数检查
数据类型检查可以用内置函数isinstance()实现

#### 返回多个值
```python
import math

def move(x, y, step, angle = 0):
    nx = x + step * math.cos(angle)
    ny = y - step * math.sin(angle)
    return nx, ny

def quadratic(a, b, c):
    if not isinstance(a, (int, float)):
        raise TypeError('a is not int or float')
    elif not isinstance(b, (int, float)):
        raise TypeError('b is not int or float')
    elif not isinstance(c, (int, float)):
        raise TypeError('c is not int or float')
    if a==0:
        return '非一元二次方程'
    if(b*b-4*a*c < 0):
        return '无解'
    sqr = math.sqrt(b*b-4*a*c)
    x1 = (-b-sqr)/(2*a)
    x2 = (-b+sqr)/(2*a)
    return x1, x2

>>> from pyTest import *
>>> x, y = move(100, 100, 60, math.pi/6)
>>> print(x,y)
151.96152422706632 70.0
>>> quadratic(0,1,2)
'非一元二次方程'
>>> quadratic(1,1,2)
'无解'
>>> quadratic(1,2,1)
(-1.0, -1.0)
>>> quadratic(2,3,1)
(-1.0, -0.5)
>>> del quadratic  #取消import
```
返回的实际上是一个tuple，按位置赋给对应的值

### 函数的参数
#### 位置参数
`def power(x, n):`
#### 默认参数
`def power(x, n=2):`

* 必选参数在前，默认参数在后，否则Python的解释器会报错（思考一下为什么默认参数不能放在必选参数前面）；
* 当函数有多个参数时，把变化大的参数放前面，变化小的参数放后面。变化小的参数就可以作为默认参数。
* 默认参数必须指向不变对象！

##### 调用
```python
def enroll(name, gender, age=6, city='Beijing'):

enroll('Bob', 'M', 7)
enroll('Adam', 'M', city='Tianjin')
```
#### 可变参数
```python
def calc(*numbers):
    sum = 0
    for n in numbers:
        sum = sum + n * n
    return sum

>>> calc(1,2)
5
>>> calc()
0
num = [1,2,3]
>>> calc(*num)
14

>>> num = (1,2,3)
>>> calc(*num)
14

```
#### 关键字参数
可以扩展函数的功能
```python
    print('name:', name, '\nage:', age, '\nother:', kw)

>>> person('Michael', 30, city='Beijing', job = 'Engineer')
name: Michael
age: 30
other: {'city': 'Beijing', 'job': 'Engineer'}

>>> extra = {'city':'Beijing', 'job': 'Engineer'}
>>> person('Jack', 24, **extra)
name: Jack
age: 24
other: {'city': 'Beijing', 'job': 'Engineer'}
```

#### 命名关键字参数
```python
def person(name, age, *, city, job):
    print(name, age, city, job)

>>> person('Jack', 24, city='Beijing', job='Engineer')
Jack 24 Beijing Engineer

如果函数定义中已经有了一个可变参数，后面跟着的命名关键字参数就不再需要一个特殊分隔符*了：
def person(name, age, *args, city, job):
    print(name, age, args, city, job)
>>> person2('J',24,[1,2],city='Beijing',job='Engineer')
J 24 ([1, 2],) Beijing Engineer
>>> person2('J',24,city='Beijing',job='Engineer')
J 24 () Beijing Engineer
```
命名关键字参数必须传入参数名，这和位置参数不同。如果没有传入参数名，调用将报错：
```python
>>> person('Jack', 24, 'Beijing', 'Engineer')
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
TypeError: person() takes 2 positional arguments but 4 were given

>>> person2('J',24,[1,2],city='Beijing')
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
TypeError: person2() missing 1 required keyword-only argument: 'job'
```

#### 参数组合
在Python中定义函数，可以用必选参数、默认参数、可变参数、关键字参数和命名关键字参数，这5种参数都可以组合使用。但是请注意，参数定义的顺序必须是：必选参数、默认参数、可变参数、命名关键字参数和关键字参数。
```python
def f1(a, b, c=0, *args, **kw):
    print('a =', a, 'b =', b, 'c =', c, 'args =', args, 'kw =', kw)

def f2(a, b, c=0, *, d, **kw):
    print('a =', a, 'b =', b, 'c =', c, 'd =', d, 'kw =', kw)

>>> f1(1, 2)
a = 1 b = 2 c = 0 args = () kw = {}
>>> f1(1, 2, c=3)
a = 1 b = 2 c = 3 args = () kw = {}
>>> f1(1, 2, 3, 'a', 'b')
a = 1 b = 2 c = 3 args = ('a', 'b') kw = {}
>>> f1(1, 2, 3, 'a', 'b', x=99)
a = 1 b = 2 c = 3 args = ('a', 'b') kw = {'x': 99}
>>> f2(1, 2, d=99, ext=None)
a = 1 b = 2 c = 0 d = 99 kw = {'ext': None}

>>> args = (1, 2, 3, 4)
>>> kw = {'d': 99, 'x': '#'}
>>> f1(*args, **kw)
a = 1 b = 2 c = 3 args = (4,) kw = {'d': 99, 'x': '#'}
>>> args = (1, 2, 3)
>>> kw = {'d': 88, 'x': '#'}
>>> f2(*args, **kw)
a = 1 b = 2 c = 3 d = 88 kw = {'x': '#'}
```
**对于任意函数，都可以通过类似func(\*args, \*\*kw)的形式调用它，无论它的参数是如何定义的。**

#### 总结
* 默认参数一定要用不可变对象，如果是可变对象，程序运行时会有逻辑错误！
* *args是可变参数，args接收的是一个tuple；
* **kw是关键字参数，kw接收的是一个dict。

####递归函数
```python
def fact(n):
    if n==1:
        return 1
    return n * fact(n - 1)

改为尾递归：
def fact(n):
    return fact_iter(n, 1)

def fact_iter(num, product):
    if num == 1:
        return product
    return fact_iter(num - 1, num * product)
```
* 理论上，所有的递归函数都可以写成循环的方式，但循环的逻辑不如递归清晰。
* 使用递归函数需要注意防止栈溢出。
* 解决递归调用栈溢出的方法是通过尾递归优化，事实上尾递归和循环的效果是一样的，所以，把循环看成是一种特殊的尾递归函数也是可以的。
* 尾递归是指，在函数返回的时候，调用自身本身，并且，return语句不能包含表达式。这样，编译器或者解释器就可以把尾递归做优化，使递归本身无论调用多少次，都只占用一个栈帧，不会出现栈溢出的情况。
* 遗憾的是，大多数编程语言没有针对尾递归做优化，Python解释器也没有做优化，所以，即使把上面的fact(n)函数改成尾递归方式，也会导致栈溢出。

习题：汉诺塔
```python
def hanno(n,a,b,c):
    if n==1:
        print(a, '-->', c)
        return
    else:
        hanno(n-1,a,c,b)
        print(a, '-->', c)
        hanno(n-1,b,a,c)
```



