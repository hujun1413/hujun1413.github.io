---
title:  函数式编程
date: 2016-12-19 20:35:26 # 文章生成时间，一般不改
categories:   # 文章分类目录，参数可省略
    - 编程语言
    - Python
tags:   # 文章标签，参数可省略
---
## 函数式编程（functional programming）
函数式编程就是一种抽象程度很高的编程范式，纯粹的函数式编程语言编写的函数没有变量，因此，任意一个函数，只要输入是确定的，输出就是确定的，这种纯函数我们称之为没有副作用。而允许使用变量的程序设计语言，由于函数内部的变量状态不确定，同样的输入，可能得到不同的输出，因此，这种函数是有副作用的。

函数式编程就是指这种高度抽象的编程范式。

## 高阶函数
一个函数可以接收另一个函数作为参数，这种函数就称之为高阶函数。
```
>>> def add(x,y,f):
...     return f(x)+f(y)
...
>>> add(-5,6,abs)
11
```

### map
map()函数接收两个参数，一个是函数，一个是Iterable，map将传入的函数依次作用到序列的每个元素，并把结果作为新的Iterator返回。
```
>>> def f(x):
...     return x * x
...
>>> r = map(f, [1, 2, 3, 4, 5, 6, 7, 8, 9])
>>> list(r)
[1, 4, 9, 16, 25, 36, 49, 64, 81]
```
通过list()函数让Itetator这个惰性序列把整个序列都计算出来并返回一个list。

### reduce
reduce把一个函数作用在一个序列[x1, x2, x3, ...]上，这个函数必须接收两个参数，reduce把结果继续和序列的下一个元素做累积计算
```
>>> from functools import reduce
>>> def fn(x, y):
...     return x * 10 + y
...
>>> reduce(fn, [1, 3, 5, 7, 9])
13579
```

利用map对list中的字符串首字母大写:
```
>>> def normalize(name):
...     return name[0].upper()+name[1:].lower()
...
>>> list(map(normalize, ['adam', 'LISA', 'barT']))
['Adam', 'Lisa', 'Bart']
```

利用reduce对list求积：
```
>>> from functools import reduce
>>> def my_prod(x,y):
...     return x*y
...
>>> def prod(L):
...     return reduce(my_prod, L)
...
>>> prod([3,5,7,9])
945
```

利用map和reduce把字符串转换成浮点数：
```
from functools import reduce
def str2float(s):
    def char2int(ch):
        return {'1':1, '2':2, '3':3, '4':4, '5':5, \
                '6':6, '7':7, '8':8, '9':9}[ch]

    def intPart(x,y):
        return 10*x+y

    def floatPart(x,y):
        return 0.1*x+y

    dot = s.index('.')
    before = map(char2int, s[:dot])
    behind = map(char2int, s[:dot:-1])   #s[:dot:-1]表示逆序的小数部分

    before = reduce(intPart, before)  #求整数部分
    behind = reduce(floatPart, behind)  #求小数部分

    return before+0.1*behind
```

### filter
#### strip函数
s.strip(rm)        删除s字符串中开头、结尾处，位于 rm删除序列的字符
s.lstrip(rm)       删除s字符串中开头处，位于 rm删除序列的字符
s.rstrip(rm)      删除s字符串中结尾处，位于 rm删除序列的字符
当rm为空时，默认删除空白符（包括'\n', '\r',  '\t',  ' ')

filter()把传入的函数依次作用于每个元素，然后根据返回值是True还是False决定保留还是丢弃该元素。
```
>>> def not_empty(s):
...     return s and s.strip()
...
>>> list(filter(not_empty, ['A', '', 'B', None, 'C', ' ']))
['A', 'B', 'C']
```

### 埃氏筛法构造素数生成器
```
def primes():
    def _odd_iter():
        n = 1
        while True:
            n = n+2
            yield n

    def _not_divisible(n):
        return lambda x: x%n > 0


    yield 2
    it = _odd_iter()  #初始的奇数序列
    while True:
        n = next(it)  #取序列的第一个数
        yield n
        it = filter(_not_divisible(n), it)  #筛法构造新的序列

for n in primes():
	if n<100:
    	print(n)
    else:
    	break
```

### 判断回文数：
```
def is_palindrome(n):
	s = str(n)
    return s==s[::-1]

>>> output = filter(is_palindrome, range(1, 1000))
>>> print(list(output))
```

### sorted
```
>>> sorted([36, 5, -12, 9, -21])
[-21, -12, 5, 9, 36]

可以接收一个key函数来实现自定义的排序，例如按绝对值大小排序：
>>> sorted([36, 5, -12, 9, -21], key=abs)
[5, 9, -12, -21, 36]

>>> sorted(['bob', 'about', 'Zoo'])
['Zoo', 'about', 'bob']
>>> sorted(['bob', 'about', 'Zoo'], key=str.lower)
['about', 'bob', 'Zoo']

逆序直接传入第三个参数即可：
>>> sorted(['bob', 'about', 'Zoo'], key=str.lower,reverse=True)
['Zoo', 'bob', 'about']
```
## 返回函数：
```
def lazy_sum(*args):
    def sum():
        ax = 0
        for n in args:
            ax = ax + n
        return ax
    return sum

>>> f = lazy_sum(1, 3, 5, 7, 9)
>>> >>> f()
25
```
我们在函数lazy_sum中又定义了函数sum，并且，内部函数sum可以引用外部函数lazy_sum的参数和局部变量，当lazy_sum返回函数sum时，相关参数和变量都保存在返回的函数中，这种称为“闭包（Closure）”的程序结构拥有极大的威力。

### 闭包
```
def count():
    fs = []
    for i in range(1, 4):
        def f():
             return i*i
        fs.append(f)
    return fs

f1, f2, f3 = count()

>>> f1()
9
>>> f2()
9
>>> f3()
9
```
全部都是9！原因就在于返回的函数引用了变量i，但它并非立刻执行。等到3个函数都返回时，它们所引用的变量i已经变成了3，因此最终结果为9。

返回闭包时牢记的一点就是：返回函数不要引用任何循环变量，或者后续会发生变化的变量。

#### 匿名函数
关键字lambda表示匿名函数，冒号前面的x表示函数参数。
```
>>> f = lambda x: x*x
>>> f
<function <lambda> at 0x000002B1B754F840>
>>> f(5)
25
```
Python对匿名函数的支持有限，只有一些简单的情况下可以使用匿名函数。

### 装饰器
在函数调用前后自动打印日志，但又不希望修改now()函数的定义，这种在代码运行期间动态增加功能的方式，称之为“装饰器”（Decorator）。
```
import functools

def log(text):
    def decorator(func):
    	@fuctools.wraps(func)
        def wrapper(*args, **kw):
            print('%s %s():' % (text, func.__name__))
            return func(*args, **kw)
        return wrapper
    return decorator

@log('execute')
def now():
    print('2015-3-25')

>>> now()
execute now():
2015-3-25

>>> now.__name__
'wrapper'
```
经过decorator装饰之后的函数，它们的\_\_name\_\_已经从原来的'now'变成了'wrapper'：

把@log放到now()函数的定义处，相当于执行了语句：now = log(now)

作业：
```
def log(func):
    def wrapper(*args, **kw):
        print('begin call')
        func(*args, **kw)
        print('end call')
        return
    return wrapper

@log
def f():
    print("hello world!")


import functools
def log(text):
    def decorator(func):
        @functools.wraps(func)
        def wrapper(*args, **kw):
            if isinstance(text, str):
                print('%s %s():' %(text, func.__name__))
            else:
                print('%s():' %func.__name__)
            return func(*args, **kw)
        return wrapper
    if isinstance(text, str):
        return decorator
    else:
        return decorator(text)


@log
def f():
    print("hello world!")

@log('execute')
def how():
    print('hujun')
```

### 偏函数
int如果传入base参数，就可以做N进制的转换。
```
>>> int('123')
123
>>> int('123', base = 8)
83
>>> int('123', 8)
83

>>> import functools
>>> int2 = functools.partial(int, base=2)
>>> int2('1000000')
64

>>> max2 = functools.partial(max, 10)
>>> max2(5, 6, 7)
10
```
functools.partial的作用就是帮助我们创建一个偏函数，把一个函数的某些参数给固定住（也就是设置默认值），返回一个新的函数，调用这个新函数会更简单。



























